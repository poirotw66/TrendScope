 Hello, welcome to not so loosely typed JavaScript with TypeScript, Zod, and Effect. There's no longer a .ts, but I was told it was too late to change the slides. So with Zod and Effect, thank you so much for being here. I talked to a few people in attendance and asked them why they're here, and some people said very excited as JavaScript developers to learn some of these things. Some people said very excited to not talk about AI for 45 minutes, and that is also true. So we will not do that. Okay, hold on. Hold on. If my boss is watching, I do like AI. That was not what I was trying to get a round of applause for. Anyway, moving on. I'm Luke Schlinger. I am a JavaScript developer advocate at Google Cloud. I love JavaScript development. All of its quirks and all of its intricacies and all of the things that we have come to love as JavaScript developers that other people might see as flaws, but we just see them as artistic interpretations of JavaScript and the language. We're going to talk about four different things. So first, we're going to talk about loosely typed JavaScript. So if you are new, it seems like we've got quite a few fans of JavaScript who have been doing development. Who's been doing JavaScript development for, let's say, five-plus years? Oh, yeah, my people. All right. And who would consider themselves new to JavaScript maybe a year or less? Anybody? Anybody? Yes. All right. Good. Thank you. Thank you. Thank you. Thank you for being here. Very excited. We're going to walk through things slowly. So some of the problems we talk about with loosely typed JavaScript might feel automatic. But what I want to make sure that this talk is not is this is not a dogmatic recommendation. I'm not telling everyone here that they must use certain things. What I'm trying to do is give you tools for your tool belt. So when you run into a specific problem, you say, oh, this is painful for me now. And now I think I want to use this tool. And so that is what I'm hoping to present you with today. So let's talk about loosely typed JavaScript, the JavaScript we know and love and sometimes can be a little bit interesting. So I'm going to make sure that I've got a fresh terminal. This is Cloud Shell Editor. This is an editor in the cloud, basically VS Code, an open source version of VS Code that has been repurposed and exists in Google Cloud. So if you have a Google Cloud account, you have access to this editor. And that is why I like it so much for demos, because if you are watching this, you can follow along at home and do this when you get home. The only other thing I'm going to do is because I'm a JavaScript developer and because I am hacky, I will go ahead and get rid of this top bar right here just to give myself a little bit more space on the page. So, all right, I'm done editing in the console now. So what we are going to do is create a fresh JavaScript project. And we're going to kind of talk through the evolution of when you might choose to pull out the next tool from this tool belt that we're talking about here. So first, we're going to start with just plain old, lovely JavaScript. So let's create a brand new JavaScript project. We are going to use Node and NPM today. We are not having the Dino and Bun flame war. They are excellent. They are lovely. That is not the topic for this talk today. Maybe next year I'll do a highly controversial, like, which one's better? And then everyone will riot. So this was from my earlier talk. Let's go ahead and remove these to prove that I'm not starting with anything in advance. So we deployed a hunk of junk website earlier today. We're not going to do that. We're going to delete this readme just in case you think there's something secret or special about that. So we're just starting with an empty project. And we're going to create, just to prove that I don't have anything on my sleeve, we're going to create a brand new folder. And we're going to create a project called whatever you say, words next, you can do it. What? The Knights of Ni. The Knights, the Knights. Is it of Ni or is it Husseini? Husseini. Thank you, Husse, but I don't know how to spell me either way. So that's an I. All right. Fantastic. Great. This session is being recorded. So now this will be a copyright violation, but this is fine. We're going to go ahead and move into this brand new folder. We're not actually going to do a whole lot with the title there. So we're in this folder, but most of that was just to prove here we've got an empty folder. So nothing on my sleeve, nothing special. Yeah. You're skeptical about the dots? These are just dots. They're just dots. Just the current directory and the parent directory. So this is an empty folder and this is where we're going to start today. So let's go ahead and create our project file. So we are going to create, we're going to say touch index.js. And we're just going to live in a single file for all of today's demo. So let's open up that file. So cloud shell, open index.js. So we've got our empty JavaScript file. So let's write some JavaScript. So we're going to say const. This is going to work the opposite of an airport. If you see something, don't say something for just a little bit. So const, we're going to say item equals, and we're going to say color is orange. And we're going to say rating is five. Five out of five for that item. So this is an item. It's got a color and a rating. And now we're going to console.log. Dot color. Okay. Perfect. All right. So now we've written this fantastic JavaScript application. And a few of you are, like, cringing. I can see it in your bodies right now. And we're going to run this application. And everything is going to be fine. Everything is going to be lovely and work just as we want it to. All right. So let's go ahead and run that. So we're going to say node index.js. Ah, okay. Hold on a sec. It is not defined. Okay. All right. Slight typo there. Let's go ahead and fix that typo. Okay. Hold on. It not defined. Ah, okay. All right. Item is not defined. Got it. Perfect. Let's go ahead and fix that. Undefined. Okay. So we can't quite get this. Oh, no. Okay. All right. We've got color there. Color is misspelled. All right. Orange. All right. This is the round of applause part. Yay. We got orange logged to the console. So that very well acted dramatization of a day in the life of a JavaScript developer brings me to my experience with TypeScript. So when I saw TypeScript in 2015, I thought a few things. I thought, number one, it does not help me because I already know the types of my objects. So not a problem. It slows me down because writing out types takes time. It's not free, right? We have to write them out sometimes. And then it is harder for me to read. There's a lot of, like, extra colons and curly braces just all around. And I think this is often still true for new JavaScript developers. I think often we throw them into TypeScript because maybe as a senior developer, we'll think, like, oh, TypeScript is better. I want them to start there. But I think there are a lot of advantages to learning with JavaScript first without all of those types floating around because I think there's a lot of things that we have trained our brains to ignore in those types as we're reading code that make it harder for people who don't know to ignore those sections. So I do think this is still true for some. But there is a very prosaic, very wise quote that my console kept repeating to me, which was cannot read property of undefined. And this mantra that I repeated to myself enough times led me to reevaluate my take on TypeScript. So when I saw TypeScript in 2020, I thought it helps me. I like knowing what I'm getting. I don't like those surprises. It speeds me up because, sure, maybe it takes me a second to write those types, but I don't need to worry about as many surprise errors. I don't need to spend all of my life debugging when things go wrong. And it's easier for me to read. I understand now what this is doing, and I like having it there. So I did change my opinion on that. So let's now talk about schema validation with Zod. When I saw Zod in 2022, I thought, this does not help me. I already know the types. I have TypeScript. I already know the types of my objects. And it slows me down. Schemas take a little bit more time to write than types, just a few extra characters. And it's a little harder for me to read, right? Instead of just putting a curly brace there, I'm going to say Z.object now. And so it takes a little bit longer. But let's go through that as the developer on this project. So we've decided we are moving to TypeScript now. So we're going to say move index.js to index.ts. The most brutal code conversion we've ever done. All right. So we've got index.ts, and we're going to open that up. We're going to say cloud shell edit index.ts. And now we have our TypeScript project. Why would you need to add anything to this? You already get all of the hinting. If I delete this R, now it tells me. Ah, okay. So I'm not going to make those mistakes. Why would I ever need Zod? And I will say I don't know if there's a reason to have Zod as long as you don't have this really pesky thing that ends up infecting a lot of projects, which is users. As long as you don't have those, you might not need TypeScript. But if some of you are working on applications with users, let's assume that maybe they have inputs. So let's say const user input equals, and then we'll have them send in their input. And this will be a JSON string. And it will be something like this. And yeah. Mm-hmm. Okay. And we're just going to do that real quick. Okay. So now we've got our user input. It's fine. Right? It's maybe, maybe they sent this to us, but now we need to figure out what to do with this input. So we've got our user input, and now we need to figure out what we're going to do. Yeah, let's parse it. Let's parse that input. And then we'll go ahead and just say our, this is our item now, is that parsed input. And we're just going to log it. Right? And that'll be fine. So color, yeah. You can watch me break this demo in real time. And when we run this, ooh, so now I get to show something that I am very excited about. So we'll run this, node index.ts, and we get undefined. Right? We get undefined, and that's because color doesn't exist. This JSON parsing cannot help us. This does parse correctly. It parses it as an object. We can log the whole thing. So we get that, but it doesn't help us with our types. Okay, so we need something to actually parse this and tell us whether or not we got the right types. And this is where Zod comes in handy. So we're going to say npm install Zod and bring Zod into our project. Up top, we'll say import Z from Zod. Is there a choir outside? What was that? Did you hear that? Am I imagining that? Back row. Is that there? We heard something, right? Okay. All right. The gentle nod. Thank you. All right. Anyway, we can move on now. If you'd like to see the choir that shows after this demo, don't leave now. So we've got user input. We've got our string there. Okay, this isn't quite working for us. What we need instead is to parse this differently. So we're going to say our const schema. Yeah. So I lied. There's a little bit of AI in this doc. So here it parses what it thinks we have up there, which is correct. That is what we have up there. We've got col and ra. And instead, we're going to turn this back to color and turn this back to rating. And then we're going to parse it. We're going to call this our item schema. Item schema. And now that we have our item schema, we can say, okay, now that our user is inputting this data, we want to validate. So this is validation of our input, input validation. How are we going to validate this? We are going to say item schema.parse. And we're going to pass in this user input. Did I delete that already? No. So this is, we're going to, whoa, whoa, whoa. All right. I did delete that. Yes. Okay. Sorry. One second here. I'll walk through the code so that it doesn't seem like I did some quick magic there. We'll call this our parsed item. And we've got this. And now when we do item.parse, we're going to pass in our, this is kind of confusingly named. Let's say parse JSON item. Hopefully that's a little bit clearer. I'm not sure that it is. All right. So we're getting our item. Now what do you expect to happen? What do you think is going to happen as this goes through? So let's read from the top. We've got this user input. We've got our item schema, which defines what we want that to look like. And then we're going to parse the user input, which is this string. It'll turn it into an object. And then this will say whether or not that is what we expect. You've got your guesses? Yeah? All right. What are we going to see? Let's go ahead and run that. Node index.ts. Is that what anybody expected? Yes. Yes. Oh, we got a few. Okay. This is completely unrelated to the code. This was, so because this is a TypeScript file and we want to run it as TypeScript, and because we are on Node 22, we cannot run it directly this way. But, but, coming soon in Node 24, already in Node 23, is the ability to strip types. The ability to strip types. And we can do this today with Node experimental strip types. And then I'm going to add, it'll give us a warning saying, hey, you're using something experimental. And I don't want that warning right now, so we'll say no warnings. Always, always a comforting thing to add. No warnings. It'll be fine. It'll be fine. And here we go. We get our errors. So, this is our, these are our errors. It's throwing right now. So, now I'm going to tell you about another personal preference of mine. This is throwing an error. One thing I really like about Zod, does anybody know what I'm about to say? Safe parse. That's right. Safe parse. So, instead of throwing the error, it's going to give me an object. So, if you're a fan of the results pattern, this, in case you're wondering, if you have friends who are Go developers, this is how you get them. This is how you get them to come over and be your friend. Right? You show them, like, look, we're going to handle errors, and we're going to handle them, we're going to expect them. Okay? This safe parse thing. They love it. They love it. Hi, Mophie. I don't know if he's going to watch this. All right. So, this is how we get our Go developer friends to say, well, maybe this JavaScript thing isn't so bad, because we've got this item now, and this item is going to have two options here. It's going to be successful, or it's not going to be successful. And so, we will say, if item.success, console.log.item.data. console.log.item.error. Now, in a real application, what I hope you would do is not just log this, but you'd probably return this somewhere, this data, to another function. And then here in this error, hopefully, you would handle the error. So, console.log.com. So, console.log.com. So, that gives you the option. Maybe you've got some custom error handling for your company. You always pass it to this. You always do some certain kind of logging. You always return it in this certain format. You can do that there. So, this is why I am a huge fan of Zod. It just makes this so easy to say, all right, we know this thing might fail. We know we're getting some user input. And maybe you show them a warning on the screen. Maybe you show them, hey, something didn't go quite right, didn't go quite as we expected it. And then you can decide what to do intentionally, rather than just throw it out there, and it's whoever's got the next file, it's their problem. Okay, so let's go ahead and run that. And now we've got this error being logged. And this error is going to tell us what the problem is. So, it gives us multiple issues, because we do have those. We have multiple issues here. And it's saying it expected a string, and it received undefined. So, it didn't get what it expected there. Expected a string, received undefined. So, let's go ahead and fix that up here. So, we've got color and rating. And I'm 50% sure this is going to work. Let's run it. No, no. What did I do? What did I do? Yeah, there we go. Yeah, at that time I did want you to say something, but it's very difficult to tell. All right, so here we've got our color and rating, and we logged it. Okay, so now we've used schema validation to get this to work. And that is really lovely, because we know exactly. Oh, I'm sorry. I didn't actually show the point of why I wanted to use Zod. The point is that if you just do this, you get any again. That's really what I don't want. Right? If you're going through all of that work to use TypeScript, and then you immediately parse something and end up with any, it's probably not doing the thing you want. Right? If what you want is types, you end up with any all over the place very quickly. So what I like to do in this case is make it unknown. Make it unknown. So there I'm explicitly saying, hey, I don't know what this will be. And that way if you change your code later and you forget to do that check, it will start bringing that to your attention. So here, if I had said parsedJSONItem.color, it's going to be very angry. Because it knows parseJSONItem is of type unknown. And that's what Zod does really well. It checks an unknown, makes sure that it's actually known, we know what the type is. Okay. So now we know that. So that's what happened when I saw Zod in 2022. And then I saw too much of this. Type any. Floating around my code. And I thought that's why I had TypeScript. And I am not trying to banish any more, because we had a very good conversation earlier this week. And I do think there could be an argument for where it could be made for performance reasons if you are very confident that it's not going to be a problem. But in general, I do not like to have any floating around my code. So with my editor convincing me and saying, these should be handled as unknown. Let's fix that. I re-approached Zod in 2023. Much faster learning cycle this time. I don't know if you caught that. But the first time, it was like five years to come around to TypeScript. I know I took too long. You were there before me. Good for you. Zod, much faster turnaround. So with Zod, I like knowing what I'm getting. It speeds me up. I don't need to worry about those surprise errors. And it is easier for me to read. Now that I understand what Zod looks like and what the shape of it is, I do feel like it's easier for me to read through and know that these things aren't going to blow up in my face later. The one thing I don't get out of the box, and you can add this for yourself with Zod, you can add your own typed errors, but you kind of need to do it all by yourself. And there are other benefits to Effect as well. But that's the one we're going to talk about today with Effect. When I saw Effect in 2024, I thought, it doesn't help me. I can get these benefits from Zod. I don't really need it. It slows me down. It's so much extra work to move everything into Effects. I'm going to functional programming now. I don't know about that. And I thought, this is harder for me to read. So let's go through what that would look like to convert this to Effect. So you can use Zod and Effect together, but most of the time, you'd probably use one or the other, because Effect does have its own schema library. So I'm going to npm uninstall Zod, and I'm going to npm install Effect. And we're going to import schema. We're going to import pipe. And we're going to import one more thing that I can... Oh, Effect. Effect. From Effect. Okay. So now we are going to be using Effect instead of Zod. So we're going to replace a few of these things. This part is mostly the same. Schema.struct instead of Object. This is going to be schema.string. And this is going to be schema.number. So just a little bit different, but the same concept here, right? We're going to be parsing this. We need to know what shape it is. Let's go ahead and do that. Another thing we need to do is we need to add these different types of errors. So Zod gave us SafeParse to give us errors without throwing, but now we want to get even more detailed here and say, like, this is the exact error we got, and that can help us find the error faster and help us debug it faster. So we're going to say class custom parse error. You two talk to each other real quick, and I don't... The last time you did that, there was an error in my code. Is that happening right now? Say that again. Oh, thank you. Yes. Okay, keep doing that. Keep doing that. That's very helpful. Yes. That was a part of it. I was testing you. Thank you. Yes, great job. All right. So now we've got custom parse error. We're going to add a read-only tag. You would typically add the constructor, but here this is a demo, and I'm going to remove that for now. So you would typically extend error and then add that. For this demo, it just very much shortened the code if I didn't do that. So now that we've got this custom parse error, the idea is we're going to do multiple steps. So here, we are going to actually be running the JSON parse and making sure that that passes as well, because before, it would just throw if that parsing didn't work, if that parsing didn't work before. And let's just go ahead and show what I mean here. So here, the JSON itself is broken. We've removed that quote. And now if we go ahead and run this, we get a thrown error, which is exactly what we were trying to prevent with Zod. You can. There are libraries that do parse JSON using Zod, so you don't necessarily need it for this, but Effect does do this very nicely. One problem I have with Effect is that I struggle to write it. It still looks very different to me than JavaScript. So fortunately, there's a fantastic tool for this, which is copy and paste. So here is the code that I will be copying and pasting, but we will walk through it, mostly because it's a little bit longer, and I don't want to type this by hand. I don't want to have to write out every single step. But here's what the code looks like. So we just got to my custom JSON parsing error. Then the next step is to write a JSON, a parse JSON effect. So this is like a try catch, but you're going to write it here with this syntax. So effect dot try, and then you've got try. What are you going to try? And then catch. And then you say, well, if this goes wrong, we're going to send a new my custom JSON parsing error. And then you write your pipe. So these are the steps. So we've really got four steps here. The first one, we try that JSON effect. We try to parse it. Then we've got this catch tag. So if we have that specific error, we're going to do this. And what I have it doing here, I'm having it succeed with a default item. So in this case, we're saying, like if it doesn't parse correctly, just use a default item. And then we're going to decode the unknown. So this is similar to what Zod was doing for us. It's got an unknown, and it's turning the unknown into an object. And then if that doesn't work, we're going to have a parse error, and we're going to log that to the DOM. This last part says we're going to run that entire program. Typically, you have one of these per your entire effects program. So you just say, I'm going to run this synchronously. A lot of times you would run it asynchronously, or you'd run promise, because most things in JavaScript eventually get to the point where you've got one promise, and now everything is a promise. And then console log results. So we'll go ahead and run that. And there we go. We get orange and rating, the same way we did before. So this is what I thought about effect in 2024. And now I started to think, where did this error come from? I want a class. I want my errors to be typed. So now in 2025, when I look at effect, I think, it doesn't help me. And I can get these benefits from Zod. And it slows me down, and so much extra work, it's so much extra work to move things into effect. And it's harder for me to read, and it adds a lot of classes. Going through these steps, I don't know if anybody caught it, but there's one operative word here that is actually the one that matters. And it's me. These are my opinions. You might have a completely different problem. You might have a different challenge that you're trying to solve. And for all I know, when I look at effect in 2026, I might think that it helps me, or I might think that it speeds me up, or I might think that it's easier to read. So if that works for you, what I can tell you is, the effect community is incredible. They've got a Discord. They are very friendly. They will answer all of your terrible questions. I know, because I've asked. And my brain just doesn't seem to quite have it click yet. But in fairness, that is what I thought about TypeScript for a long time. It didn't click for me for a long time. And then finally it did, and now I'm a huge fan. So every time, every project that I create this year will probably include TypeScript and Zod, because I love them, and I get them, and they make sense to me and my brain. But if they don't make sense to yours, this is not me trying to tell you how you need to write your code, but just a tool belt. When you get sick of cannot read property of undefined, think about adding TypeScript. When you get sick of having any's floating throughout your code base and getting surprised by them in production, think about using Zod. And when you get sick of not knowing where your errors came from exactly, and what the type or shape of the error is, maybe think about using Effect. There are other ways to solve them, but these are what these tools are built for. These are the problems they solve. Thank you very much for your time. I will stick around for questions. I appreciate you being here today. Thank you. Thanks for the time. Thank you. Bye. Bye. Bye. Bye. Bye. Bye.