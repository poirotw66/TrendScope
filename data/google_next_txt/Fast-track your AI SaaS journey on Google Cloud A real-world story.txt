 Adarsh Seetharam Hello, everyone, and welcome. My name is Adarsh Seetharam. I'm a senior product manager at Google. I'm super excited to be here with you today. Before we begin, let's take a quick survey. How many of you are facing difficulties in adding AI capabilities to your SaaS? I see a few hands. How many of you have tenants that require dedicated instances of your SaaS? Think for compliance or personalization reasons. You're in the right session. We're at a pivotal moment in technology where AI is redefining how businesses operate and software is delivered. I'm excited here to talk about something that is at the intersection of these two powerful forces, AI-powered SaaS, and how we at Google are simplifying the deployment and operations of next generation of these SaaS applications. The overall SaaS market continues its explosive growth. Experts project a staggering trillion dollars of market by 2027. And let's be clear, a significant driver of this growth is the need for AI-powered solutions across various industries. AI is revolutionizing applications in three key areas. Enhancing user productivity, using data and insights to make decision-making faster, and personalizing experience so that users, you have better engagement with users. Let's take a closer look at how SaaS has evolved. Traditionally, SaaS has always been about automation, accessibility, and subscription-based pricing. But AI is redefining these core pillars in a profound way. From automation to intelligence, early SaaS automated, repetitive tasks. However, AI transforms these automation into intelligence, predicting, learning, and optimizing workflows in real time. From accessibility, from accessibility to personalization. Traditional SaaS made software widely available with a consistent set of experiences across all users. AI takes it to a step further and helps you personalize your SaaS experience at an individual customer level, thereby increasing engagement and outcomes. From fixed pricing to dynamic monetization. Where SaaS once relied on static subscription, AI enables per-tenant dynamic pricing, usage-based billing, enabling you to optimize your revenue. As you can see, the landscape hasn't just changed. It's been fundamentally transformed. However, embracing this future isn't without its challenges. Traditional SaaS already had enough complexities that made it difficult to manage at scale. With now the added complexities of AI, these issues are amplified. We've talked to many customers who are grappling with these challenges. Let me know if you agree with some of these challenges. The first challenge that we've heard is about personalization. You're building great SaaS products, but how easily can you customize the experience for different verticals? Say, healthcare or financial institutions. How can you offer different feature sets for or different functionalities for different users? Perhaps based on their subscription tiers. What we've heard from customers is that doing this at scale is incredibly hard. Next, how easy is it for you to streamline your deployments? You've got different environments, different tenants, different functionalities, and frequent releases. Managing the deployments across all your tenant instances is incredibly hard. Next key challenge is monetization. Are you able to get your SaaS to your customers easily, seamlessly by integrating with Marketplace? Are you able to offer a frictionless experience for your customers to onboard to your SaaS? And finally, insights. Are you able to understand the tenant experience for your users? Can you optimize your SaaS to offer the best possible experience for each tenant? Well, what if there was a better way? What if you could focus on building your innovative AI-powered SaaS without getting bogged down by the operational complexities? Today, I'm thrilled to announce the public preview of SaaS Runtime. SaaS Runtime is Google Cloud's fully managed service management platform for service producers. We have built this from the ground up and using our years of experience at Google, knowing how to build. We know a thing or two about how to build services at scale. So, the mission of SaaS Runtime is to dramatically simplify the building, deploying, and operating of SaaS, especially those infused with AI. But don't just take our word for it. During the preview process, we've been working with early adopters. And I'd like to, this is a good time for me to invite Santosh Pan, SVP of Engineering from Avathon, to talk about their experience working with SaaS Runtime and why they chose Google Cloud for their SaaS transformation. Santosh? Santosh Pan 미안hmedixt to speak here, to speak, how to build a project. Great, thanks. Thank you. Santosh Pan, thank you. Santosh Pan, thank you. Santosh Pan. Hello, everyone. I hope you are having a great time at Next. I'm excited to be here to have a product launch of SaaS Runtime. Thank you for having me. Santosh Pan, thank you. Santosh Pan, my name is Santosh Pan, and I lead the R&D at Avathon, responsible for our industrial AI platform. At Avathon, we see a key pressing challenge. We believe over 100 trillion of infrastructure is under stress, whether it is an underperforming asset, an aging workforce, a shortage of skilled technician or supply chain disruptions. These factors impact efficiency and reliability of an asset. Our mission is to extend the lifespan of an asset, maximize the performance and minimize disruption while progressing towards fully autonomous industrial operation. So how do we do it? We take a holistic AI based optimization approach by focusing on three key areas. Intelligent digital twin, we integrate real time sensor data, sight, sound, vibration and even smell. This allows us to monitor, diagnose and even predict the failures of an industrial asset. Not only we detect the failures, we also prescribe the solutions. Spare part supply planning. Since we can predict the failures, we ensure that these key components are at your inventory without any delays. We also monitor this industrial sites for health and safety, security, compliance and using the visual AI. When you combine all these three areas together, you will realize that you can accelerate the human centric region support and workflow automation, progressing towards again and fully autonomous industrial operation. So no longer do you have to wait for an asset to fail or bring down your operation based on the schedule. Recent years have brought preventive and predictive maintenance to extend the life of an asset while minimizing the disruption. The next generation is already seeing the rise of AI power agent that they don't only diagnose the problem, but also look for an opportunity to implement a right solution. Like 3D printing of the field part at onsite. At Avathon, we are leading this way to drive an agentic approach to an asset management platform. So we work across three different verticals and one horizontal energy, oil and gas and renewable, aerospace and defense, detail and CPG. All this horizontal connect back to the one horizontal, which is a manufacturing and supply chain. Since our customers span into this diverse industries, the challenge is onboarding. We needed to have a multi deployment strategy, single tenant and multi tenant. So how do we do this onboarding and also a very smooth implementation? We wanted to have a solution that we can give in hands of our services team and also to our channel partners, helping them to onboard our customers very effectively and very smoothly. With SaaS runtime, we think it can address all these pain points and many more. We estimate that this will dramatically improve the onboarding and streamline our SaaS operation. If you want to double click on any of this topic, feel free to reach out to me at s-month at avathon.com. Thank you for again, giving me this opportunity. Thank you, Santosh. We're super thrilled to be working with innovative companies such as Avathon in our journey to help service providers improve their onboarding and operation of their SaaS. We're looking forward to continuing collaboration with your team. The product we're introducing today, SaaS runtime, simplifies SaaS management through a streamlined three step process, model, deploy, and operate. Let's take a closer look at each of these. It starts by modeling your SaaS on SaaS runtime. Imagine you're building an inventory management SaaS that has an application layer, an infrastructure layer, and an AI inference engine. SaaS runtime helps you map your SaaS architecture into logical, reusable building blocks called blueprints. In this example, you would create three blueprints, one representing each of your SaaS components. If you already have a SaaS up and running, you can create these blueprints by integrating with your existing code repositories and importing infrastructure as code using Terraform into SaaS runtime. If you're designing your SaaS from scratch, you can use the design canvas in our newly launched application design center to create your application and import the Terraform generated into SaaS runtime to create those blueprints. You can also integrate your existing CICD tools and set up build triggers to automatically update these blueprints every time you make changes to your SaaS components. Once you've defined your blueprints, SaaS runtime helps you manage dependencies across these blueprints seamlessly. For example, you can define your infrastructure as a dependency of your application so that every time you deploy an application, infrastructure gets deployed automatically. So once you've modeled your SaaS, deploying new tenant instances becomes incredibly streamlined. First, you create a release for each of the blueprints you've defined. SaaS runtime then helps you automate the provisioning of tenant instances based on these releases. Following our previous example, you would create three different releases for each of the blueprints that you've defined. Now you have the ability to create instances of your SaaS that have a combination of these components. For example, based on the pricing tier of your customer, you can decide to provision instances from all or some of these blueprints. Once you're ready to onboard a new customer, you can quickly provision and map a dedicated slice of your SaaS with ease. For example, onboarding retailers into the basic tier might involve creating an instance that has components from infrastructure and application blueprints. Onboarding a customer to your premium tier might involve adding an instance that has an additional component from the AI blueprint. SaaS runtime really helps remove friction in customer onboarding and makes onboarding seamless. Finally, effectively operating your SaaS at scale requires robust management capabilities. And SaaS runtime offers a rich set of tools for day two operations. Starting with helping you automate tenant onboarding from marketplace or from your own control plane using our APIs. You can reliably roll out application updates across your entire fleet or to a part of your fleet. SaaS runtime provides the ability to filter these rollouts based on tenants, based on environments such as dev, staging, prod, or other labels that you can specify, enabling granular control over your deployments. Now let's consider that you're thinking of introducing a new AI feature. SaaS runtime helps you define a feature flag for this feature and target specific tenant cohort and initiate a feature flag rollout. This allows you to turn on the feature without requiring a redeployment of your binary. More importantly, this decouples feature availability from your code deployment cycle, accelerating feature velocity. SaaS runtime also helps you with a rich set of observability and provides controls to optimize your deployments. You can track the progress of your rollouts in real time, control these rollouts. For example, you can pause, cancel, or resume these rollouts. And monitor resource utilization across your tenants all on a single pane of glass. In summary, SaaS runtime is designed to empower you to build and scale your SaaS with unprecedented ease and efficiency. It allows you to model your SaaS in a flexible and reusable way, helps you streamline your deployments, and optimize your deployments, and operate your SaaS at scale reliably and consistently. Now I'd like to invite my colleague Praveen to the stage to give you a sense of how SaaS runtime is in action. And you'll see how easy it is to SaaSify an application. Praveen. Praveen Praveen Praveen Praveen Praveen Praveen Praveen Thank you, Adarsh and Santosh, for that overview of SaaS runtime. I'm going to actually show SaaS runtime in action. Before I begin, let me set the context for the demo. I'm going to introduce Symbol AI, a mock ISP, that offers a learning management system. The Learning Management System is a web application that is capable of providing training academies the ability to offer customized learning plan and serve that globally across multiple regions. Let me quickly list symbol education schools. One, they want to use AI to be able to offer customized learning plan, seamlessly scale and manage their SaaS, and finally, the ability to offer pricing tiers. Let's now demonstrate how SaaS Runtime can help you easily build a scalable and secure learning management SaaS. This is an example architecture of a learning management system. Here, we have a Java-based web application that has a MySQL backend, and it is served using Cloud Run and then exposed via a global load balancer. Symbol uses Terraform to actually store and deploy their learning management system. Let's get started with the modeling step that Adesh mentioned. First, we need to create blueprints that represent the template of our SaaS instance. Next, these blueprints are essentially packages of Terraform modules of the learning management application. In this example, we are creating blueprints to represent two major components of SaaS. The first blueprint, we are going to call this the base blueprint, is essentially bootstrapping all of our infrastructure components in Google Cloud, like project, network, service accounts, etc. The second blueprint is our learning management application blueprint, and we are going to call this LMS blueprint for the purpose of this demo. Using SaaS runtime, we can define dependencies across the base and the learning management blueprint. In our example, the learning management blueprint depends on the base blueprint. It essentially inherits all of its infrastructure information from the base blueprint. The resulting model combines the learning management blueprint with the base blueprint and inherits all of its infrastructure information. With this as the context, let's quickly look at SaaS runtime in action. Here, we are looking at the Google Cloud Console. I'm going to search for SaaS runtime. This takes me to the service page. Here, for the benefit of our demo, I've already created a SaaS offering called LMS Demo Live in my US Central Region. We are going to start by creating our base blueprint. There are a bunch of options to create blueprint, but I'm going to start with linking an external repository. I'm going to pick a repository from GitHub. I'm going to choose my main branch, and then I'm going to proceed with configuring my blueprint. Let me go and pick the location where I want to store my blueprint. In this case, I'm storing my blueprint in the artifact registry. I'm going to give it a name called base blueprint. Pick the Terraform version. Choose the service account that has the permissions. And then I'm going to create the unit kind. In the context of the demo, we all need to understand what a unit kind is. A unit kind is nothing but a SaaS runtime data model abstraction for a blueprint. All the infrastructure resources that are created as part of the blueprint have the same lifecycle. So I'm going to call it base unit kind. Pick the SaaS offering that I created earlier. And then I'm going to go into configuring my release. I'm going to provide a value calling it base release 1-0. And I'm going to hit create. This is going to take a few minutes to create. But in the meantime, I'm going to take you to an environment where I've already created the base blueprint and the learning management system blueprint. Let's go into the learning management system blueprint. You see that this blueprint has a dependency on the infrastructure. It also has a bunch of input variables. These are essentially how you dynamically pass values to your blueprint. Going to another environment. I also want to walk you through the other options that were available for creating the blueprint. I can upload a zip file of my Terraform. We already linked our external repository. The last option is selecting an image directly from the artifact registry like others pointed out. If you want to link it to your existing CI CD system, you choose this option. Let's go to configure. And I'm going to go to my registry and pick the version of the blueprint. The next is defining the unit kind. This time, let me just say I'm going to define the LMS blueprint. I pick the offering. And here is where I would actually add the dependency. Here, I can go and pick my base unit kind that I just created, and I can call it infradependency. Hit done. I could enter the release and then follow the same process of creating the unit kind. Going back, we see that the unit kind has been successfully created. Let me switch back to the slide. Now that we have successfully modeled our SAS, let's go and use SAS Runtime to deploy our first instance of Learning Management SAS. I'm going to go back to my demo. Deploying an instance of SAS is necessarily a two-step process. The first step is to create a unit. A unit essentially represents an instance of my SAS. In this case, I'm going to call it LMS-U-8. And I'm going to pick my SAS offering, pick the region. And then I'm going to provision my Learning Management System application. So I'm picking LMS unit kind. And here I see labels. Before I add the label, I want to switch to my slide and then explain tiering in the context of the demo. Customers in the premium category get additional AI capabilities that is hidden behind a feature flag. Later in the demo, I'm going to be showing how you use a feature flag to enable or disable a feature. But let's go back to the demo. I'm going to add the label with a key tier and I'm going to say this tenant is basic. I'm going to create the tenant. This is going to create an instance for me that I can now provision. So I'm going to go ahead and provision this tenant. I'm going to pick the release. Again, pick the service account that has the appropriate permissions to create all my resources. And I'm going to add an input variable. This is the dynamic passing of values to my blueprint. So I'm going to pass a tenant ID for my blueprint and I'm going to call it TNT-8. And hit provision. This is going to take a few minutes to provision. So in the meantime, I'm going to switch to another environment where I've already provisioned a demo LMS unit so that, you know, we can save some time. So going into the unit, I see that I have the tier basic. I also have all the values that were dynamically passed. And then the key thing is the last section where you see SAS runtime recognize the dependency on the infrastructure. It automatically provisioned all of the infrastructure components required. And then it deployed the application on top of it. Now let's switch back to the application itself. Before that, since the application is running, let me go ahead and associate the tenant with the instance that I just provisioned. I have seven tenants that I've already created. So I'm going to create my eighth tenant here. Going to call it tenant-8. I'm going to choose the same SAS offering. Again, choose the region. And then before hitting create, I'm going to choose the demo-8 unit that was provisioned. And I'm going to create the relationship between my tenant and the instance. I'm going to hit create, and this is going to create my eighth tenant. Let's go into the application and take a look at what this learning management system is all about for Symbol Education. Logging in, I see that this application is for user John Doe. And browsing, I see a lot of courses that are available in different categories. I also have mock tests. I want to call your attention to these two links. There are three tests that this user has taken in the last couple of days, and I want to get feedback on test number three. So I'm going to click Test Report. It's actually taking me to a giant feedback page, and I really do not have time to review this right now. So I'm going to go back and download Test 3 for offline analysis. Let's keep this in mind, right? And now everything is good, and SAS Runtime has helped Symbol Education grow. So I'm going to switch to another environment where I've onboarded 50 different tenants using SAS Runtime. Now, how did we get here? Let me switch back to my slides. Tenant onboarding at scale is a very key feature. You can get to the state of 50 tenants using three different steps. One, just like I showed, use SAS Runtime UI. The other is Cloud Marketplace. Use the APIs that help me onboard my tenants and have that link directly to my Cloud Marketplace and start onboarding tenants. And finally, the last is use a custom control plane application to go and add the tenants. Let me show you a mock of how this looks. This is a mock control plane application. You see a bunch of training academies that are already onboarded, right? And this is an add tenant screen where you can potentially capture different metadata about all of your tenants. And these are the three values that come from our backend. So you can use SAS Runtime API calls to fetch values like releases, name of our unit, region, all of those. And that is an example of an API call that you can actually make to get those values from our backend. Now everything is good. And then suddenly we get a message from our sec ops saying there is a vulnerability with our application. Patching a security vulnerability is a classic use case of operating SAS at scale. Let's now see how SAS Runtime is going to fix the vulnerability. I'm going to go back to my demo. I'm going to open a command prompt. And I'm going to call my load balancer endpoint. And you're going to see that the response is actually unrestricted. This has the potential for DDoS attacks. I do not want that. So let's go ahead and see how we can patch the security problem. I'm going to create a rollout. I'm going to say LB security fix rollout. I'm going to pick the LMS unit kind, the learning management system unit kind. But here I'm going to pick release 2.0, which actually has the fix. I'm going to go ahead and create the rollout. This is essentially kickstarted a process of patching 50 different instances of SAS. So what I'm going to do is I'm going to go to an environment where the rollout has successfully completed. This is how a completed rollout is going to look. And here is the observability page that shows 49 of the 51 instances have completed successfully. Two have not started. We can definitely go back to logs and understand what's going with those two instances. So what happens to my environment after a rollout has been successfully completed? I'm going to go to a different environment where I'm going to simulate how this rollout actually fixed my vulnerability. Now I'm going to issue the same curl command that I issued earlier. And, you know, it's going to give me 200 responses for the first 15. And then it's going to give me 403 for the remaining because I just patched my load balancer. So let's go back to our slide to see what this looks like. We successfully rolled out Cloud Armor to all of our tenant instances by the click of a button. Contrast this with patching and infrastructure change for 50 different instances that could be spread across so many different regions. That brings me to the last part of my demo. We still haven't addressed one key goal for symbol education, which is I want AI capabilities rolled out to my premium customers. So just like before, what we are going to do is create an AI blueprint and have it depend on the LMS blueprint so it gets all of the information about the application. This is how the premium customers architecture has now evolved as a result of this AI blueprint. Let's go back to the demo and see how we can accomplish this. So others talked about feature flags. So I have this feature flag that's actually rolling out the AI capabilities to my premium tenants. It's currently in the disabled status. So what I'm going to do is go and edit this flag. Change the value to enable. Save it. Save it. Save it. Once it's saved, what I'm going to do is go back to feature flag. And this time I need to create a flag rollout. Right? I'm not rolling out the binary. The feature is already there. It is hidden behind this feature flag. So what I'm doing is rolling out this feature flag to a subset of tenants. So I'm going to call it flag rollout. And instead of picking the LMS rollout kind, I'm going to pick the AI agent premium rollout. This is essentially what is filtering the instances based on the premium label. So I'm going to create the rollout. While the rollout is happening, let's go and see what our AI unit kind actually looks like. This is the AI blueprint that was rolled out to a select customers. Going in, again, it's the same thing. We have it dependent on the LMS unit kind. If you look at what are all the instances that this is associated with, I have a subset of six instances, not the entire 50. So let's go into one of those instances. You see that this is, again, dependent on the LMS unit. Right? I'm going to go to the application instance now. You see that it has the premium tier label. And it is able to automatically recognize this filter. So now that I've rolled out the flag, what I want to do is go back to my tenant application. This was the application that we saw earlier. Now let's go ahead and re-login. What you will see that the two links that we had there are now replaced by an agent that is going to provide me feedback dynamically. Let's go and see what that feedback looks like. See, the agent recognized that I was user John Doe. It also took all the context of the previously completed tests, and now it's ready to provide feedback in a dynamic manner. So I'm going to ask the question, tell me about my weak areas. You'll see that it's going to tell me prescriptive answers about where I'm actually weak based on how I've performed in the test. And then I'm going to ask it to provide customized learning plan. And it's going to give me a learning plan that's tailored around how I can improve and get better scores. Let's switch back to the slide. I want to take a minute to explain what we just did to enable the feature. This is especially important in the context of making your SaaS AI-powered. We used the AI blueprint and the feature flag to dynamically enable the capability for specific tenants who had the label premium. So we built a simple, secure and scalable SaaS. I'm going to do a quick recap of what we just did. We started with a single tenant application or a simple application. We wrapped multi-tenancy around that and created multiple dedicated instances of our SaaS using SaaS Runtime by following three simple steps. Model, deploy and operate. Then we multiplied those instances by creating more tenant instances using the SaaS Runtime API. We also defined dedicated isolation boundaries through projects for our data and resources. Next, we secured our SaaS. All the blueprints that we used, used Google Cloud best practices. And we also patched a security vulnerability at scale by helping Symbol Education keep their security posture. And finally, we were able to offer personalized tenant experiences. We offered AI capabilities to just our premium customers. With that, I'd like to turn it back to Adesh. Thanks, Praveen. How exciting is that? And we're just getting started. You've now seen how SaaS Runtime provides the ability to first create flexible and reusable components called blueprints. Helps you integrate with third-party CI-CD tools. Helps define dependencies between blueprints. So when you deploy one, the other one gets automatically deployed. Second, you can define releases for each of the blueprints and manage release versions. Provision instances based on these releases. Map instances to your customers' tenants. And third, you can automate the onboarding of your customers. Roll out binaries, feature flags, and other configurations. And gain insights and optimize resources across all your tenants. And we're just getting started. In the near future, you can expect us to have deeper integrations with Marketplace, Application Design Center, and Gemini to make it even more easier for you to host your SaaS and manage your SaaS at scale on Google Cloud. If you would like to see a live demo and have questions answered, please visit our partners. Better still, if you want to take it for a spin, visit our Cloud Console or scan the QR code and give it a try. Thank you and have a great next. Next.