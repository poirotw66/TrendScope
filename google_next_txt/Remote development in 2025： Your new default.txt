 Thank you everyone for joining this afternoon and the first day of Next. And thank you for also joining a breakout that does not contain the letters A or I in it, at least in the first slide. So hopefully this will be informative and give you all some new tips and tricks here as you're looking to take back new skills and do different development things here as we get into some of the fun things that we've launched and all that stuff. The title of this talk, I named Remote Development 2025. I should have named this for myself Remote Development in 2022. Fun fact, a lot of this is actually structured on a few things. One is what I do in terms of my role, which I am a tech lead for our cloud developer relations team, which means I get to work with developers across the world on different and complex projects that they're working on. And the more personal thing is that in the... It was March of 2022. And I had a laptop stolen from me out of a car in California. And at the time, I was very thankful that that laptop had very little on it, and I gained a new appreciation for what we kind of call remote development across a number of different things in it. In my prior life, I was a consultant, and if that laptop had been stolen, I would have had about six months, probably to a year of pain associated with all the things in it. And we'll talk about why remote development really makes something like that almost a trivial, although not a fun event, but from a security perspective, very easy to go through in it. So what are we going to do today? I aim for, just as a time check, roughly a half hour of demos and slides, and then I love questions. So feel free, once we get into that, anything here in the topic that we can help to answer and make a group discussion out of it. But why now? Why is remote development? I think we talk about it. How is this kind of becoming the new normal, and why is that the case? And then we'll go through some different things, or what I kind of call day one, day two, and day three. Day one, in this case, what are the different tools that you have available to getting started in Google Cloud? Day two, what is that actual developer flow? What's kind of my version of it, and how can you take some of those things back? And then day three, helpful tips and tricks and things that I've learned along the way that hopefully are useful for you to take back to your organizations, or even just yourself doing development on your laptop as an individual contributor. All right, so we talked about remote development, I think, at this point for probably, in earnest, six or seven years. I remember when Visual Studio Code came out with the whole notion of remote containers. I believe that was either 2018 or 2019. We looked at you like, that's cool, but why are we running containers in this stuff? That seems like a lot of work. And at the time, cloud compute was still relatively expensive compared to the performance we were getting on some of our laptops. So why is now different, right? We always say that this is the year that we're going to do something. For me, this is the year that I'm going to do better at something. This is the year that I'm going to practice my golf game. I'm still terrible. So why now, right? Well, first off, I don't know if you've heard, but there's a chip crisis, right, in particular for things that are very valuable with AI tools and generative AI. I'm sure everyone here has just a couple H100s laying around, right? You know, here, if we think about doing development, the big thing now is how do we do development? How do we do it faster? How do we do it across different architectures? You know, I mostly do development on a Mac. You know, I'm on an ARM architecture, but there are a number of things that still require x86 architectures to actually, you know, compile and do different development things on. What I don't want to do is carry around two or three laptops for doing all of these different things and all the permutations of it. So how do we think about, you know, remote development as a way to enable these things across the stack for developers? Second thing is how do we actually, you know, use remote development to get better at governance and security? You know, we talk a lot these days about how data is really kind of that oil, right? And I think that expression has probably been around for a while. If you think of, you know, LLMs, you know, all these new things, right? We talk about data moats and protecting our data. Sometimes we don't always talk about our code also being the data that we have as an organization and the value and the logic associated with that. So, you know, remote development here is almost, in essence, a way to also create a moat around our code, which is, you know, our business logic and how we create value off of our data. We shouldn't necessarily be treating it any differently with things like, you know, relatively open access and that sort of stuff for it. As geopolitical, you know, things continue to change. You know, residency is continuing to also become more and more of a requirement. So how are we actually keeping things in the region, right, where it's supposed to be in and not just, you know, making sure, having to have everything processed in the U.S. is an example, which happens with some organizations. And then last but not least, you know, I think we're kind of at a time where capability, you know, and the speed is really becoming important. But doing it in the context of both governance and security, you know, is kind of a requirement for it. You know, just playing around with many of the AI-enabled assistants that exist in IDEs, they're great, right? But, you know, how many people have really vetted the terms of service, right? Are you thinking about where your data is going? I'm sure everyone here is right, but you probably have developers in your organization who are like, I just got to get something done and it's a four-hour deadline. I'm going to do this thing. And you're like, well, the imperative is good, right? The fear is real that something's going to leak and, you know, then you end up with some of these things that you've seen from other organizations where it's like, hey, there's keys and other stuff in this data. Obviously, that's very bad. So how can we actually make sure that we're doing things both quickly with capability but also securely across our remote stack for it? All right. So I said a lot of things about, you know, remote development, remote development, but let's just ground ourselves in a definition. I think this is, you know, hopefully relatively straightforward, but it is the process of developing or interacting on a remote where essentially our device that we're using just becomes, in essence, a thing client or something, you know, that I could just go buy off the street. You know, if we think about computers today, right, you can get a really good computer, you know, for doing everyday tasks for probably $600 or $700, which is insane if you think about, you know, the 40 years of progression, you know, from a pricing perspective in this stuff. But that doesn't mean that that's going to be right for everything, right? As I kind of mentioned earlier, you know, what it may do really well for everyday tasks, it may not do well for certain things like encoding or other things. So how do we, you know, find the right remote pieces for it? And the goal here, right, is that we enable collaboration and communication. We do better secure our code as data. We also enable workflows. So how can developers work more together, whether that's folks like user research plus frontends plus backends, all, you know, enabling a better cycle of development. And then making sure that we have the tools and tech and remote development to support those pieces of it. So we do all this, right, and the goal of essentially, you know, enabling developer productivity. So I won't go through all these, right, but I think, you know, everyone talks about flow state. I think vibe coding is like kind of an amusing flow state, although I will say I've been doing it more. And it's interesting, you know, if you really understand code, how fast you can use some of these new tools to do that work. But the goal here, right, is that how can we do things that are engaging to us that provide us value, but also get us to the feedback very quickly, right? So I write code. I can see those iterations. I shorten that feedback time because ultimately those are the things that as developers lead us to not being able to release features and functionality very quickly. And then last but not least is really what I think of in all this is like the cognitive load. So, you know, each of us here probably has multiple code stacks that we work in, but the thing with that is that there's so much knowledge that we have, probably somewhat in documentation, but mostly in our head about the code that we're working in, and how can we actually leverage tools like remote development to actually better share that knowledge and then make the entirety of our groups faster for it. So one more slide here, and then we'll get into all the fun stuff because the code screens are always the best. But when we talk about, you know, ways that we can use remote development to enable developers, it's really important for us to think about kind of the inner and outer loops of development. So starting here, just in our inner loop, oh, if I know how to use the clicker, red button goes back, there we go. All right, so the first one is code. Obviously, we all write code, right? These are the things where it's, hey, you know, I just need to, you know, generate something, I need to fix something, I need to, you know, refactor something, all these things, right? There's a lot that we write now about, like, how you can use LLMs for this stuff, but how do we also talk about the tools that enable those sorts of activities? Second is doing things like builds, right? So what are, you know, if I put all this stuff together, is it going to actually compile? You know, if I'm running a front-end app and I do NPM build, you know, what are all the dependencies and packages? You know, one, will it compile? Second, like, how many vulnerabilities are there in those? Am I using a package that has a vulnerability? Obviously, you get kind of the list and the 2 million warnings with it, but, like, which one's actually important and how as an organization are we addressing that? And then the other one is testing, which, you know, if we think about most code pieces, we all probably would like to write more tests, but, you know, if it runs once for me, it must run for everyone else, right? So how do we make sure that we're, you know, bringing that code to it or even automating a lot of these pieces as a part of our inner loop flow? So I think here in remote, it's important to kind of think of the two as distinct but almost equally valuable. So if you think of outer loop development, right, and this is kind of my background starting off in data engineering. Data engineering used to be very hard to do inner loop because if you think about it, you know, there was one Teradata appliance that had probably 500 terabytes of data, and if you're lucky, you had a dev instance that was, you know, eight cores. So in reality, what we did was we developed on production because that was all that we had available to us. That said, if we had something like this where we could have taken, you know, easy sample sizes of data and done different things with them, it would have ultimately made this part much more easy because, you know, we're testing, you know, different things in micro doses than building that out to everything else. And this is where, you know, if we talk about CICD, right, these things are still highly useful, right, how we're building integration pipelines, how we're testing, you know, the full set of everything that developers are releasing, how we're actually releasing and deploying that, right, you know, in different models for doing those things for it. So remote development can help with each of these. You know, in some cases, it is doing inner loop development to improve the outer loop for other developers, but it's also thinking about, you know, what has been outer loop development or outer loop builds and how can we actually move that back to be even closer to the developer to be able to do more and to do it faster for it. All right. So let me go ahead and shift over here. So we're going to do three things today. First off, we're going to talk about some of the improvements that we're making in Cloud Shell and just do a quick drive-through of that so folks here can see it. Second of all, we're going to actually spend more time in cloud workstations talking about some of the principles with remote development and then how we can do that in Cloud Shell and how it actually can unlock a lot of things that we may not have thought possible. And then last, we all cover some of those best practices that I've learned here over time. So let me go ahead and I will cut over here to my device. Cool. And let me make this full screen. All right. This is the Google Cloud homepage. It's super fun and it has boxes for things like quick access. What it does have up here also is this friendly little Shell logo here that opens Cloud Shell. How many folks have used Cloud Shell before? Almost 75%. Awesome. So let me talk a few things about Cloud Shell that you may not know as we get into it. First and foremost, and I think this is the first thing that we always pop up, I don't know why we do it this way, but it's like, hey, guess what? Here's a terminal. You know, like, is this, you know, 1986? Like, what's going on here? Isn't there something that has to be better for me to actually use as an IDE in this stuff for it? Well, sometimes, right? As this is reconnecting, you know, one of the things with Cloud Shell is that we have both the terminal here, which makes it easy for us to, you know, run commands from quick starts, even do quick tasks. But the second thing is that it actually does have a full-blown editor called Code OSS, which is essentially the base for tools like Visual Studio Code and other, I forget what the editor is called, but a number of the different tools out there, including Windsurf and Cursor, all these kind of the same base piece for Eclipse. No, not Eclipse. It'll come back to me at some point. All right. So once we're here, there's a couple things we could actually do with Cloud Shell, which start to actually make it pretty nice. First off, all of this is ephemeral. So the compute is ephemeral, which means that, you know, once I'm not using it, I'm not paying for it, we'll just turn it off in the background. You know, what I did, it's just essentially reallocating me a small instance to be able to run my code on. That said, my data or my disk is actually durable or persistent. So if you're using something like Cloud Shell, you can always come back to it as long as you're logged in with your user account, even across projects, to be able to do different pieces of coding development for it. If we were to take a look at mine, we can see here that, you know, I have a few things that I've actually downloaded that we'll be using in the next one, and I'll make it a little bit bigger. But you can see I've cloned a repo. I have a few other things here. If you saw my google.com one, you would see five years of history and essentially file mismanagement across all the things for it. I should really clean it up, but just to show you how much you can actually store you on a disk within it. So next thing I could do, let's go ahead and we could pop into an editor here. And so again, this is just using essentially the code OSS shell for it. I'll go ahead and authorize. And then we'll connect in. And here I have something that looks very similar to Visual Studio Code, which is nice. But the new thing here that we've actually also enabled is that Gemini Code Assist is now enabled by default if you're using Cloud Shell Editor. So here, you know, what's nice about this, right, is that we can go through, you know, I can start to, even if I want to just try out Code Assist, maybe for a set of use cases that I have, it's very easy to configure here and use those different pieces. I can even go through and, to some extent, install different extensions, you know, within this appliance. And then, you know, I can even do more, you know, more data management and those sorts of pieces for it. I can even see some of my different repo pieces and I could go and do my development here like I would, you know, any other developer doing work during a regular day. The other piece here, which is actually, I think a lot of people don't know about, if I wanted to, I could actually, you know, do, like, front-end development here and this little web preview icon means that whatever I'm running, let's say I'm running NPM run dev, I could click this and then Cloud Shell will actually be my remote where it's executing my code and then I can essentially use the equivalent of a tunnel to get through there and to be able to, you know, do hot reloads and all those fun things for it. And we'll actually, I'm not demoing that here, but we'll see it here. Again, with workstations, the motion is very similar. So a lot of things here, you know, Cloud Shell is great if you're thinking about, hey, what's just a thing that I want to do in Google? Can I prototype something quickly? You know, great, I got the idea. I got it done in 30 minutes. I can go share this with someone else and do all those fun pieces for it. All right, so let's shift over now and we're going to talk about cloud workstations. So a few things that workstations essentially came from in this was one that Cloud Shell Editor actually runs in our VPCs. So they run in Google-managed VPCs. We have Google-managed IPs. That created some issues with, you could imagine, very large organizations where they said, hey, that's fine, but you're Google. What I really want to do is run those things, but I want to run it in my own environment so I can guarantee different things like security and usage and all that fun stuff for it. We said, that's interesting, tell us more. And they said, well, we don't just want, you know, think tools like Code OSS. We want to be able to run things like JetBrains or we want to be able to create our own environments for developers to be able to enable their developer flows because we have custom tools just like everyone else. We don't just use Gmail and GDocs and Cloud Build. We're like, okay, that also seems reasonable. So what can we do about it? Well, that's where we now have the concept of cloud workstations that we can essentially deploy. So here I am just on the workstations page, and we'll do a drive-through of a few of these things, and then we'll hop into how we can connect to it here. Show a hand. How many folks have worked with workstations before? Almost double digits. We were so close. All right. So what are cloud workstations? Workstations. Well, here you can see they are secure and managed development environments on Google Cloud. What does that mean? There's a couple different things that we think about with workstations. So what workstations enable us to do is to manage separately clusters. So think of this as where are computes running. From configurations, which you're kind of like Docker containers that say, hey, what are the different code pieces and what are the different extensions that we want to run? And then to the actual workstation that I might deploy as a developer for a specific workload in it. If I come here to cluster management as example, we can see here that I've created my first cluster, and in this case, it is the demo config. And what's great, if I go into cluster management here, is that we can see a couple things that are actually very important, is that I'm able to attach these within my own, essentially, project to my own VPC and my own subnets for it. So right off the gate, right, if you think about, well, hey, how do I start to make sure that my access is only to things that my developers should have access to and know more, we're starting from a base of, well, hey, here's our network perimeter, and if you want to do development, you have to do development in our perimeter. Great place to start, right? Kind of, like, easy way to say, okay, hey, if it's not in the perimeter, you can't access it in these things for it. We'll show some ways here how this becomes even more important when we think about production, infrastructure, and all that. Second piece is in my configuration. So if we think of the configurations, these are really kind of the templates that we're saying, hey, you know, Jason is a developer, what do you want to run? You know, what are the options that are available to you and those things for it? So here I've essentially created a configuration, which is to say, hey, here's what the machine, the developer machine looks like that you can actually access, and here we can see a few things for it. So the first one is, you know, what sort of machine type do we want? In this case, I'm just using an E2 standard, but here, and we'll look at the screen, you can actually attach GPUs to, you know, a subset or a configuration here, and this becomes really powerful if you think about, you know, hey, I want to do my own development with GPUs. Okay, great. Well, you're not going to buy GPUs for everyone in your organization, but you probably might have a couple, so that way when people really need it, you can allocate it to them to do their development work for it. I can also specify, you know, a number of different things, including, you know, using, like, confidential VMs or shielded VMs if I'm really concerned about the security of information on those machines. And then ultimately what I can also do is then specify different environment settings. So, you know, think of this as, hey, I want everyone in my organization to have these five extensions when they load up code OSS. You know, I want them to have cloud code and code assist because you should all use those, right? It's your shameless Google plug there. You know, maybe I also want to have a Kubernetes-type thing. I want to have Terraform, and I want to have, you know, maybe a Git extension that we just all find really useful. Well, you can start to specify these once we start to get into some of our different configurations where you're just specifying this as a Docker container to be able to do your different workflows. And here you can see we have a repo here for custom image examples. And you could take one of these and then essentially either build your own from scratch if there are specific versions of, you know, Linux that you want to, you know, run your different code on. Or you can also start from our pre-built images here like our code OSS image and start to use it. Here, just for reference, what this one is showing is I have a Chrome sample. So what this is doing is actually installing a browser on code OSS and then integrating the browser into code OSS so you can do, you know, more web front-end development-type activities for it. And here, again, the goal, right, is it's like we're enabling developers to be in their flow state. What we're not making them do is go manage all these things, including, you know, downloading, installing, figuring out why something doesn't work on sudo, you know, suing, then running your thing, you know, coming back to it, restarting their machine, all those things for it. These are the things that, you know, if you think about, well, why does it run? Your machine or not mine? You do it and then you realize eight hours later it's because they don't have a package installed and it's like everyone's lost today and everyone's frustrated. So here, right, you know, the goal is let's all be on the same page when we're starting to write our code so we can then do the fun things with it. All right, last thing here, and then we'll shift over to actually working with these things. We can see here that we can then create workstations. So workstations, if you think of kind of bottom to top, we have our cluster, which is our compute. We have configurations, which are allowed to use, and the workstations are actually me as a developer saying, I want to use this. And you can actually, there's a few things you can do here. One, you could say, hey, a developer can only have one workstation at a time. You can also say, hey, you know, a JSON could load up three at a time. And maybe that's because, you know, I have one small instance that I use for something very, you know, for my general development. And maybe I have like one massive thing if I'm compiling like a bunch of C++ libraries and I use it for that sort of development. And what this allows you to do, right, is start to get into this kind of mix and match scenario where what we're doing is picking the right compute for our right developer task, not just the workload that we're going to be executing on it. All right. I'll go ahead and hop in here so we can see this cloud workstation. We can see that I have a host. I have a different couple of configuration things. And then here I could actually go ahead and launch it. So let's go ahead and do that. And the first place this will take us to when it loads up here is something that looks very similar to what exists in VS Code. Or sorry, in Cloud Shell Editor. So surprising, right? Here we can go through, we can also add our extensions, you know, do different things for it. And this, if I want to say only in the browser, is really quite an easy way for us so then you'll continue our developer flow for it. However, what I will say, right, is that, you know, as much as we want to use remote development, most developers still want to use local IDEs for doing work, right? Like logging into a browser, even for me, like feels kind of unnatural to actually then have to use for all these different things in it. And what's great here with Workstage is that we can also connect to it and use a very similar flow that exists in Visual Studio Code for remote-based container development. So let me go ahead and shift over here. All right. All right, so for reference, where I am, I just opened up, I am in Visual Studio Code, and we can see here that I have a very similar look to what we had in Cloud Shell Editor. And here, there's a couple things, right? This looks almost like regular Visual Studio Code. There's one big difference. So if you look down here on the lower left, we can see that I've actually connected to, in this case, a remote instance. And what I'm doing here is with this one little command here on one line, is I'm connecting to my cloud, I'm connecting to my cloud workstation via Visual Studio Code. So in essence, what we've been able to do here almost immediately is move off of my laptop, even though I'm still using my laptop, but move to a remote container for now doing all of our development work. So if you remember my story from earlier where I lost my laptop, here, no harm, no foul, right? It still sucks that my laptop got stolen, but it's a $600 machine. There's no proprietary information on it. There's no additional things that we need to fill out. I'm logged in here. I can do my work just like I would anywhere else, and it's even as performant, right? So I'm copy-pasting back and forth, doing other things, and I'm not taking that performance instead of even using a web-based application. Here, we're also adding a local host. So in this case, we have a port that's open, and now we're just doing a TCP tunnel into our instance, and I can also hear I have SSH set up if there are other things that I want to be running on it. All right. We're back here. I'll get through a couple more things. Oops, wrong one. I always forget my tabs. All right. A couple more things here. So here we can see that I'm essentially at a Streamlit app, right? So I'm using an app here from this repo. Well, one of the things I want to do, right, because this is Streamlit, is like this allows us to do kind of hot-ish development on some of these code pieces. Well, what I can do is here, again, I have a virtual environment set up, and what I'm going to do is actually run Streamlit as an app. And even though this is running on the remote server, I can still actually do web-based development. So here, you know, I don't, like, this is taking care of all the tunneling and all the other stuff that I usually screw up. And it looks almost the same, right? I have localhost 8081 because I forgot where 8080 is running. But I can do all the fun things here. So I could go through. I can change some of the Gemini things. I can say, you know, what color is the sky if I wanted to? I can go ahead and execute this. But this is an easy way, right, where now we're actually also running things remotely but able to interact with them locally and our development loop hasn't actually changed as a result of this, which is really nice. Another thing here that we'll touch on and then get some tips and tricks is, you know, if we think of kind of the world of, you know, what's, like, addressable and across all of our different software pieces and then what do we want to keep private, almost every company now in developer group that I talk to is like, we don't want to use public IPs anymore. One, I think Amazon charges an arm and a leg for them. I think it's like $20 a month. But second, right, like, what you're doing when you have something attached to that is, like, you're saying, hey, there's a security thing here that I'm just inviting the world to try to hit on and then try to actually hammer and get into for these pieces of it. Probably don't want that anymore, right? Moving to private IP only is a, and that is a very easy way for us to actually take that and then lock it down. So what we've done also, because we're in that same VPC and that same subnet, is we can actually interact with things in our project or that are attached to a shared VPC like we would anything else. But the benefit here is that, oh, let me find it. Let me get the command here. Oops, sorry. All right. So I pasted in this command here to essentially connect to a Cloud SQL instance, but what you'll notice is that I'm also using an internal IP address for it. So in this case, I only have the internal attached. There's no public IP. So essentially my Cloud SQL instance is only addressable by things that are in the network. And if I was to do this, we can see that I have a user prompt here. And forgive my copy paste here for one more second. Go ahead and do this and then come back over. Paste it in there. And we can see here, now I'm actually connected to my Postgres instance, and so I can do all the common remote things that I want to do for it. I can tell you that setting these things up, when we're talking about production, is hard, right? Because we're talking about traversing typically an external entity that's available, these internal things. What we don't want to do is have to spend our development time also doing this for our internal processes. And this is where, whether it's Cloud workstations or even a compute engine instance that you're hosting, this makes it easy to just develop like you're actually using these things in production and all the fun stuff for it. All right. We could also go through here. We can install some things, but I'll go ahead and shift over and just cover some also tips and tricks that I've been picking up along the way that are hopefully useful, and then we'll shift over into Q&A. All right. So first thing, when you set up different things like subnets, one of the things that makes this work is that our subnet here has private Google access enabled, and what this means is that traffic, when you're doing development or you're running something in production, will actually traverse our private backplane where possible. So it makes it easier to be more secure right out of the gate and use things like private IPs, private DNS records, all those fun things for it. Second thing that I've learned along the way is making sure, and we showed this earlier, but customization of images actually is very powerful and important. So hey, what are those extensions that I want? What are all the things I want my developers to have, and what are none others that I want them to be able to do? Here, if you think about, you know, even using, like, generation tools, you know, this makes it easy for someone just to come in, be productive day one, because they already have the tools set up and they're not asking, you know, Jason for what are the five tools that he's using. They're not asking, you know, Mark for the three tools that he has. It's all there and available, and people can see it ready to go for it. Next thing here that's also very important, and this is more for the platform admins in the room, you know, one of the things that I've seen work very well is having sandbox projects that are different from development projects, and the reason for that is that, you know, we want development rights to look like the things that we're actually going to do in dev tests and prod, but in sandbox, like, anything goes, we don't want it attached, and if something happens, like, blow it away and start over again. So, folder structure here is really important to enabling developer experience. It enables us to have playgrounds. It enables us to think about, you know, the things that maybe we want to use to actually modify our flow and all the fun things for it. So, keeping in mind, right, this starts ultimately at IAM and resource hierarchy. How do we enable developers at that point for it? Another thing here, you know, we talked about extensions, but thinking of these things as a marketplace for your internal teams, you know, this is really a critical thing. You know, whether you're using a registry like OpenVSX, whether you're hosting your own, you know, packages and installation things and artifact registry, you know, these are things, right, that make it easy for me as a developer to come in, be productive, and then ultimately be happy. I think we think, you know, in many cases, developers want IDs, you know, they want their own IDs and all that. What they just want is the tools to be available, and most developers don't actually have that strong of a preference as long as something that's available that does the thing that they need it to do. So make it easy for developers to do all that work for it. Last thing here, and then we'll shift over, you know, the other thing that I do always encourage is to think about, you know, what is that, if you think of a culture of experimentation and collaboration around this, you know, think about your code and think about a way to, just like we would think about sample data, right, for testing different things, think about sample code for testing new flows. So, hey, is it a repo that's kind of, you know, on the side, but it has a few of our most complex pieces in a de-identified method? Great. Let's use that. Let's go test Windsurf. Let's test Cursor. Let's test other tools to be able to see, will they change my development and all the fun things for it and then be able to do it? All right. So let's go ahead and shift back over to our slides here. So what did we do today? We talked about, you know, how remote development is changing and how we can really start using it in 2025 to be effective. We've covered Cloud Shell Editor, you know, how does that use? And then talked really about how you can get started with workstations and use that as kind of your container developer development environment of choice here in 2025. I hope all these tips and tricks are helpful. I know it probably seems at the end there there's just a few things, but, you know, here are the goal, right? Make developers happy, get you all doing fun stuff, and reduce all the friction of the things that suck that we don't want to do. So with that, let me open up to questions in the room and happy to answer. And there's folks with mics that are just running, so just a heads up if it takes 10 seconds. But first one in front. So you made that capital of your security to benefit. If you lose your laptop, there won't be any harm. So how do you invalidate your laptop from accessing your workstation in case you lose your laptop? Is there some... I saw you connect to your workstation from your Visual Studio code? Yeah, so... It can't be established. That's a permanent connection until you time out or... Yeah, so what's... Like, if I close this, like, and that was what I was scrambling to do, like, when I come, like, it's just like a session. So I close the laptop, the session's dead. So I have to do that. And then, you know, this is where it's like, hey, well, what happened? Well, you were logged in with your identity. Call someone, that identity's no longer good. Reset the identity. Guess what? They can't access any of your cloud resources anymore. So, like, honestly, that part was, like, I called and I was like, it was a terrible discussion from the perspective that I had to have it. It was a two-minute discussion. Like, everything shut off. You're good to go. You have to call somebody in your cloud admin site to invalidate your identity. Yeah, or I could, like, I could do it on my phone, but, like, the Google setup is, there's just a lot, there's a lot of other stuff for it, but, like, I think they answered in, like, 30 seconds. Thank you. And second part is, how is the latency between your Visual Studio code, you developing and everything going over TCP tunnel? So what is your developer experience like? You have any lag, any kind of? So that's why I prefer the actual, like, the, like, downloading, like, the Eclipse plug-in and all that. Like, to me, like, the lag is basically not noticeable. It's not like a web browser, like, you do feel, like, a little bit, right? Even though we say it's, like, it's, like, developing, you know, on your device, like, you can still feel it, especially if you talk, like, thousands of lines of code that you're moving back and forth. But, you know, it feels, it's very, it's, like, pretty seamless. And you can debug also from that session pretty seamlessly, not just launching your app in the browser, but also if you want to debug, you can debug. Yeah. Yeah, it gives you, essentially, what happens is it installs, like, a server-side controller. And so it's the same, like, JetBrains is very similar. Like, when you run it, you actually have, like, a gateway which sits on your device and it's connecting to their, essentially, like, language servers and other stuff which you're running, like, on the remote. So, you know, it's a great way of just kind of bifurcating the services that you need for it. Thank you. Yep. Question in the back. Thank you. So, from a workstation perspective, you kind of touched on the importance of the image customization piece. And so, you know, if we wanted to, you know, roll a bunch of our own images that were aware of our internal GCP infra, you know, ready for attaching to any, like, enterprise artifact repos or any other, like, applications from a corporate app store, say, everybody loves, like, Cursor or something else like that. Like, what are your, do you have preferred tools or workflows that kind of, you know, bridge that gap between, hey, I want this image to know everything about my GCP infra, but it also needs to be flexible or extensible enough to incorporate, you know, maybe we use JFrog artifactory, maybe, you know, developers want to use, you know, a certain coding assistant. Like, what are your thoughts about how we bridge that gap just kind of acknowledging the criticality of the image customization? Yeah, so what's, there's a couple of things here and hopefully there's enough nuggets here. So, when we think about, you know, what can we do to customize these, all the different things for our developer flows, you know, first, right, you can always start from just a simple base image and add on. So, a developer's not locked down necessarily to saying, hey, you can only use, like, these things on it. Hey, I want to enable them to still, you know, add additional extensions to it. They can have those privileges on their specific workstation. It's just, you know, specific to their workstation in it. So, the image here is really, like, what's the, kind of the minimum that I want everyone to have accessible to them? From there, as you think about, well, hey, I want them to have access to this but not to that, what's nice is when you're running this, you know, essentially in a VPC, you can actually use, like, your network and use tools like VPC Egress or service controls to say, okay, great, you can go to this but you can't go to that. So, you can say, hey, well, some, you know, developers have a choice, right? They can use, like, they can use quad models with Codium. You know, they can also use Gemini models. Well, you can then start to lock down other DNS things based on just, like, network and firewall rules that are available to you. Kind of. Just acknowledging the dynamism of infrastructure, right? You don't kind, are you aware of any tools or do you have any tools in mind that can sort of discover some of those changes so the onus isn't on, like, the developer who is maintaining or customizing those images to be aware of, like, all of these changes that are, you know, always happening? Yeah, and so let me see if I can answer this. So the question is, like, what can be done so a developer doesn't have to do all, like, I as the developer doesn't have to do this, right? So this is where if you're using, like, images, what's great with that is that you can actually, as, like, a platform admin, you can build the image and everyone can have access to it. So, you know, a developer could customize past that, but, you know, you're just saying, hey, there's new things coming up and we want to, you know, pre-bake this thing into it. Platform admin can change the image and then it's available to everyone in it. Does that help to answer your question? That assumes the platform, that kind of assumes that the platform admin is aware of all the things and, you know, pick on any Fortune 500. Like, I don't know many platform admins that are super aware of, like, all those different pieces simultaneously. I think maybe in, you know, I'm happy to follow up more if there's a specific thing. You know, this is where it's like, we talk about doing development for development. You know, having some of these things like in just repos that developers can actually modify. Hey, like, Jason thinks that this new extension is great. Well, why can't he just check it? You know, why can't he commit code, you know, to the image and then have the image be available? You know, I think, you know, that's probably how I would start to approach that is like, hey, here's what the security team needs. Here's what the platform admin team needs. But they just approve the PR at the end of the day for these things and then it's widely available. You know, use that for collaboration and then bringing those pieces to life. Time for one more. Sorry, there's a gentleman in the back there. Blue shirt, yeah. Hi. Yeah. I'm kind of curious about when you're developing remotely, who are you? In other words, I did see that you chose a service account. Is every developer getting to their workstation as that or are they getting there as themselves? So, in this case, my identity has access to the workstation but how I access the workstation is just using a user. So, like... So, I mean, like for access, if you're doing remote development, let's say you've got access to a few open source things and you pull down the Git code and you want to actually, you know, work simultaneously across several repos, some internal, some external and then push the results. Will you be pushing them or committing them as yourself? Yeah. Okay, great. Yeah, so, like, the part that you didn't see, you know, when I went to, like, configure my G Cloud account stuff, like, even on that target, I'm using, like, my authorization. So, it's my identity that's doing the actual work from it. All right, we are at time. Thank you so much. I hope this is really useful for everyone and look forward to seeing what you can build.