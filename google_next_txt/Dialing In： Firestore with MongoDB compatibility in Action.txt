 . Good afternoon, and welcome to Dialing In, Firestore with MongoDB compatibility in action. My name is Min Nguyen, and I am the Senior Product Lead for Firestore. Joining me today are Patrick Costello, Engineering Manager for Firestore, and Dana Hoffman, Senior Engineering Manager at Dialpad. You are in for a treat today. We'll kick it off with a brief introduction to Firestore, and then we'll get hands-on with a live demo of Firestore's new capabilities. After that, you'll hear from Dana and Dialpad, who will share how Firestore has enabled them to build and scale their AI-powered communications platform. Finally, we'll wrap it up with next steps and questions and answers if time permits. Let's get going. Firestore's mission is to help you unlock application innovation with simplicity, speed, and confidence. We do this in three primary ways. The first is through an enterprise-grade document database that is built and tailored for your company's needs. This is reflected through an advanced and expressive query engine that allows you to build customer-centric applications. The database service also meets your information and security requirements using familiar Google Cloud governance tools. Second, Firestore is completely serverless. That means it scales dynamically with your business, offers fast performance, and is also backed by an industry-leading five nines of availability guarantees that your business can rely on. Third, Firestore is built to maximize developer productivity. We do this through a broad range of support for different drivers and SDKs in programming languages that your developers are already familiar with. Firestore also makes it incredibly easy for you to migrate your data from another existing document database. Firestore is built to Firestore. And when you choose a document database, you're choosing a community. I'm proud to share that Firestore has over 600,000 active developers. Eight million databases in use. And over 1.5 billion end users are interacting with Firestore-enabled applications today. In the spirit of maximizing developer productivity, I'm excited to share that this week we are announcing Firestore with MongoDB compatibility. You can now use familiar MongoDB drivers, tools, and open source ecosystem integrations with Firestore. Let's take a peek at how this is enabled under the hood. But before we do that, let's start with some of the common challenges within traditional document databases. There are two notable challenges that administrators face today. The first is scalability. And the second is reliability. Traditional techniques to solve these problems tend to incur high complexity. For example, with scaling up techniques, operators frequently face costly database downtimes when having to scale up or scale down. This requires them to have to over-provision their document database in order to manage bursty traffic. Second, for common replication techniques, developers have to deal with eventual consistency between replicas. And operators have to deal with handling failovers between replicas. Furthermore, replication techniques can help you scale your read throughput, but it doesn't address your write throughput. And for sharding techniques, there are high operational complexities whenever you hit a shard limit, requiring you to have to rebalance shards. Furthermore, there is a high hidden cost to sharding, both in distributed queries and distributed transactions. This is where Firestore is different. Firestore manages scaling and availability on your behalf. Let's take a look at how this works. Firestore utilizes a differentiated backend that offers automatic, real-time rebalancing of disaggregated compute and storage. It allows Firestore to add resources exactly where it's needed, in real-time, with zero operator intervention. Furthermore, Firestore's storage is fully sharded and replicated across different availability zones. When a document is written into Firestore, Firestore utilizes a protocol called Paxos, where a leader-initiated write quorum is achieved across replicas. In the very rare case that a replica zone or region goes down, Firestore automatically elects a new leader within its replica set. This is done with zero downtime, zero data loss, and zero operator intervention. Firestore then goes hard to bring back the unhealthy replica zone or region. And once everything is healthy again, the replicas start serving without missing a beat. Okay. Now that we've covered storage, let's get into compute. Firestore's compute layer implements multiple developer-friendly APIs, including the Firestore with MongoDB compatibility API. These APIs then call into Firestore's advanced query engine to serve requests. The Firestore advanced query engine supports popular data types like JSON and BSAN. It also supports over 120 popular operators and stages. Familiar operators like count, regular expressions, and even joins. Familiar operators likeson. Familiar operators like JSON and BSN. To make it easy for developers to access these new features, we are now announcing a brand new query editor experience in the Firestore Cloud Console. The editor allows you to write queries using the MongoDB query language without installing any software. Firestore also now supports brand new index types. For example, with the sparse and non-sparse indices, we are now giving developers full control over whether or not a document with a matching field or without a matching field is reflected within an index. And with multi-key indices, you can now improve the query performance over arrays, including nested arrays. A key part of the developer journey is understanding query performance and billing. With query explain, you can understand the detailed query plan of your queries, the performance metrics, and the billing metrics as well. Frequently, it's your end users that are running dynamic queries. And with our new query insights, you'll be able to see the top queries that are performed on your database in order to assess the performance of those queries and to understand how you can optimize them. And for those DBAs that are managing a large fleet of databases, Firestore is now integrated into Database Center. You'll be able to utilize Database Center and Gemini Cloud Assist to inventory databases and receive proactive recommendations of how to improve configurations like disaster recovery, security, and compliance. All right. All right. All right. All right. Quick show of hands with the audience. How many of you are already utilizing a document database today? Fantastic. Looks like it's a majority of you. Well, coming soon, Firestore is offering live migration tools to make it easier for you to move your data to Firestore. Now, for those of you responsible for financial operations, Firestore's pricing is simple and cost-effective. You only pay for the actual traffic on the database. Read and write operations conducted on the database are measured in four kilobyte and one kilobyte tranches, respectively. Storage is built based off of actual consumption, metered daily. And network egress is only incurred when traffic is occurring outside of that database region. Firestore's pricing model is highly differentiated from traditional document databases that typically have a high hidden cost. Since scaling is operationally intensive and incurs downtime, DBAs will typically over-provision their databases. With Firestore's serverless pricing, however, you're only billed for the actual traffic incurred. There's no resource provisioning, no forecasting, and it's fully automated, and we scale in real time based off of your needs. The savings, however, don't stop there. In today's economy, we understand it's pretty tough. And with Firestore, I'm excited to share we are now making available committed use discounts. With a one-year commitment and agreement to Firestore, you'll see a 20% savings. And with a three-year commitment, you'll see a 40% savings on Firestore operations. Last but not least, I'm excited to share the upcoming API interoperability between Firestore with MongoDB compatibility, Firestore native, and Firestore with Datastore compatibility. This allows you to utilize your MongoDB drivers, Datastore SDKs, and Firestore's real-time and offline SDKs together. And with that, I'd like to invite Patrick on stage. We will demonstrate the features of Firestore. Thank you, man. I'm excited to show just how easy it is to use these new features of Firestore and how they will integrate with Firestore's new MongoDB compatibility. Let me show you what using Firestore could look like at an e-commerce company, Symbol Direct. Symbol is an online, direct-to-consumer, footwear, and apparel retailer. Their storefront servers were built using Firestore with MongoDB compatibility to leverage our developers' vast experience with MongoDB-compatible clients. Their architecture is built on a MongoDB, Express, React, and Node.js stack, with Cloud Run as our computation layer and Firestore with MongoDB compatibility as our backend. Firestore has allowed our e-commerce company to scale rapidly. Let's take a look at how we could build the logistics network to support order management in our distribution centers. Let's go over to the demo. Oh. There we go. Who in the audience wants to help me debug my Wi-Fi connection? We'll try this one more time. All right. All right. Let's go back to the demo. Awesome. Here's the storefront servers for Symbol Direct. We can see it offers a number of shoes that we can purchase. I'm going to walk us through what using the storefront looks like and what the code for that will look like. Here we can pick out a couple shoes. This isn't a real e-commerce store, so if I need a couple extras, that's okay. And then we'll go ahead and place our order. Let me show you what is actually happening in the code. This here is the order express router. This is going to get called any time the user presses a checkout button. We can see it processes the order. It's going to create a connection to our Firestore with MongoDB compatible database using the familiar Node.js driver that we are familiar with. Then we're going to insert that single order into our database. We're also going to add a couple of new fields. The purchase time, the status of that order, and if we're actively tracking it or not. Now, when we look at our distribution center, our UI team has built out this really amazing frontend that is going to allow us to track orders as they flow through our system. But right now, we can see there aren't any orders here. I think we're going to have to write the backend code ourselves. Here is this new warehouse router. We've already defined the request for it. In this case, the request will contain the ID of the order that we're looking to update. It will include the status of the new order and who the order is assigned to. Here we can see this is called every time someone from our fulfillment team tries to change the status of an order. We're going to have to implement this to store it into the database. First, we're going to use a get a connection to our current MongoDB compatible client. Then we're going to get the collection of orders. And then we need to make an update to the current order. So, first, we're going to get the ID. We're going to find the order by ID. Then we need to set a couple fields. First, we're going to set the status to the status that was passed in to us. Then we're going to update the assignee. And finally, we're going to update if this order is currently active or not. And we are going to just say an order is active as long as it hasn't been delivered. Using this familiar MongoDB compatible Node.js driver, we're able to very quickly implement code to integrate with our system. Before we start looking at the read side, let's go test some queries and see what our data model looks like. We can take advantage of any of the tools that we are familiar with. In this case, we're going to use the VS Code extension. Let's just look at our orders and find a pending one, see what it looks like. Here, we're going to match for any pending status, and let's just start with one of them. You can see in this connection string, we're connected to our Firestore with MongoDB compatibility database. Here is one of our orders, and we can see it has the products in that order, as well as those fields that we set when the order was placed. We also have access to a wide variety of tools from Firestore with MongoDB compatible developers. Using the new Firestore Studio query editor, we're able to issue queries in the syntax that we're familiar with. Here, we can see we've run the query, and we get our results with similar purchase statuses. We can also leverage Firestore's new query explanation tab, here I'll switch to it, to get a little bit more detail about how that query was run under the hood. We can see in this case, Firestore with MongoDB compatibility does not require you to build indexes ahead of time. In this case, we issued a table scan to process this order. Now, our warehouse fulfillment portal is maybe going to have a lot of activity, so let's build an index to optimize that. The portal itself is going to show all active orders, and we're going to want to sort those by oldest first. Let's make sure we have that right index. Here, in our indexes view, we can see the collection ID and the fields that are relevant to that query I just described. Let's go back to our query editor and make sure we issue the right query. Here, if I add another filter for active orders, and we can remove that limit. We can see now this query is run on the index that we just created. This is great. Let's go actually write the code to make this happen. When I look at this order UI, one of the things that I would think about is that we really want our fulfillment team to see changes to the orders in real time. We want to make sure everyone is up to date on who is handling a specific order. We could write some complex client-side synchronization and real-time logic, but we could also take advantage of Firestore's innovative real-time and offline SDKs. Let's take a look. Here's our client-side code that is leveraging the React framework. We can see here we have an order provider. This is where we will process orders and place them into the UI. We can use Firestore's new real-time pipeline API to issue a query. The real-time pipeline API is easy to use and fluent, making it really easy for our developers to write the code they need to. First, we'll look at the orders collection. We'll filter for only the active orders. And then we're going to sort them, oldest ones first. And that's the definition of our query. Now, what's going to make this really interesting is having this available in real-time. Firestore's innovative watch protocol will stream only the changes to your query that happen. This allows us to, in all of our clients, very easily listen to changes in that query and then re-display the UI when those changes happen. Here, we listen to snapshots for those queries. And when a new snapshot comes in, we can just set the UI to look at that order. Just like that, we're done. Now, we've implemented a real-time, offline client. Once we deploy this, we can see it in action. I've already pre-deployed it, so let's go look and see what it looks like. Here, I've pulled up our two portals side by side. We can imagine that there are two users in different parts of the warehouse fulfilling orders at the same time. Importantly, we can already see that these real-time changes are flowing in as our team handles orders. And when we make changes in one, which flows through the Firestore with MongoDB compatibility APIs, we can see those reflected immediately in the other using Firestore's innovative real-time and offline SDKs. Here, I'll go mess up someone's order and say, yeah, I actually did ship all of these. And you can see them immediately reflected from one user's portal into the other. Let's go back to the slides. With this new architecture, we were able to quickly build out SymbolDirect's real-time logistics tool, leveraging data interoperability between Firestore's MongoDB-compatible interface and Firestore's innovative real-time and offline SDKs. This allows developers to maximize existing libraries and tools from both of the MongoDB and Firestore developer communities. I'd now like to welcome Dana Hoffman to tell us about how Dialpad has built an AI contact center, leveraging Firestore over the last 14 years. Dana? Thank you, Patrick. It's great to hear about all the Firestore developments announced at Next this year. We at Dialpad are very excited to start incorporating them into our products. As Patrick said, I'm Dana Hoffman, Engineering Manager at Dialpad, responsible for our cloud infrastructure. I have been with Dialpad for over seven years now and have been responsible for building and now leading teams that manage and maintain our core cloud infrastructure, helping Dialpad modernize and scale our services. I'm excited to share with you how we use Firestore to achieve scale on top of GCP today. But before we get into how we leverage Firestore, a quick intro to Dialpad. Dialpad is an AI-powered customer communications platform. We elevate every conversation with deeply integrated AI across calls, messages, and meetings. We empower our customers to tap into real-time insights, support customers, and collaborate with colleagues. We've built a suite of services to deliver exceptional voice, messaging, and meetings. And our real-time AI recaps make sure everyone stays in sync during the call and after. On the inbound side, we're handling everything from intelligent routing and virtual agents to AI-powered CSAT analysis. For outbound engagement, we're equipping your teams with smart playbooks, automated dialers, and real-time coaching. All your customer communications together in one beautiful application. Talk to your customers through voice, video, and messaging. Accelerate work with real-time AI, generating real-time insights, coaching, and actionable analytics. Scale efficiently and securely, confident that you're future-proofing your organization. Let me walk you through our three core products. Dialpad Connect transforms how teams collaborate. Our foundational solution brings everyone together. Employees, teams, and customers with an AI that takes notes, surfaces insights, and enhances every interaction. Dialpad support revolutionizes the Connect Center experience. It gives your support teams the AI-powered tools they need to deliver exceptional customer experiences with real-time assistance that makes every agent, human or agentic, your best agent. And Dialpad sell is changing the game for sales teams. It automates the tedious parts of selling, provides real-time coaching during calls, and helps your team close more deals with AI-powered insights. Each product is powerful on its own, but together they create a seamless experience that empowers frontline workers, gives managers actionable insights, and ultimately delights your customers. For every workflow, there is a purpose-built AI that delivers a better experience for users and your customers. From our foundational AI that provides real-time, highly accurate documentation of every interaction, to specialized tools like AI CSAT for customer satisfaction scoring on 100% of your calls, and an AI live coach for real-time agent guidance. Each component is designed to deliver immediate value. When we started our AI journey back in 2018 with the acquisition of TalkIQ, that's right, we were in the AI game long before Gen.AI became trendy. And the result is that our AI operates at enterprise scale that no one else in our industry compares to. Our proprietary dataset contains over 8 billion minutes of real business conversations. We've executed over 345 million AI recaps and over 1 billion minutes summarized. And because of this foundation, 97% of our Connect Center customers leverage Dialpad AI. Building a real-time voice and video communications platform with integrated AI is no easy feat. Users are extremely sensitive to latency, so critical flows must be fast. Callers don't stay on the phone long listening to dead air while we try to route your calls. And an AI real-time assist card that comes 30 seconds late doesn't help the agent much in closing the deal. Furthermore, powering a communications platform requires consistency and high availability. For many businesses, the communication platform is the lifeline to their customers and prospects. And when the lines are down, their business is down. Even missing a single call isn't acceptable for many. A few things are uptime. Achieving low latency, high consistency, and amazing uptime requires great infrastructure. And Firestore is one of the key pieces of our great infrastructure. Now, every SaaS company aims for low latency and high uptime. But our line of business came with an increased challenge to achieve them. Our daily traffic pattern isn't like most. Before we entered the Connect Center market, Dialpad was focused on UCAS, providing a business collaboration platform, which meant that we were subject to when businesses wanted to collaborate. Calls would surge at the top and bottom of every hour. So, from the get-go, we at Dialpad had to embrace the challenge of huge traffic swings every 30 minutes. And no one, no matter how hard we've tried to incentivize them, schedules their conference call to start at 9.07. But we are also a startup and had to keep our costs low. Paying to over-provision at those levels wasn't an option. So, we chose a hybrid cloud approach, keeping our media processing servers localized to regions around the world, keeping media latency low, and our business logic in the cloud running on serverless architecture of App Engine. and now Cloud Run. Using many other GCP services to achieve distributed processing. And Firestore being the glue that held it all together. With serverless computing, our front ends could scale up and down automatically with the traffic swings. But our system isn't a simple request-answer service. There is long-term state that must be preserved throughout the lifetime of a call. And Firestore provided that solution. With fast lookups and put operations, we could keep latency low and leveraging transactions, we were able to maintain state and item potency between the distributed nature of the serverless architecture. Serverless computing is designed to auto-scale. But we needed our data storage solution to scale as well. And again, Firestore again met that need. It continues to consistently respond at similar low latencies, regardless of the peak load. As you can see, our P95 latency is fairly constant, even with the sudden traffic swings at the top of every hour. And Firestore grows with our usage over time as well. We have plenty of APIs and workflows built years ago that have more than 100x in QPS. But we've never had to change the schema to meet the higher demand. We built it once and it continues to grow along with us. Highly available auto-scaling with consistent response times is impressive in itself. But Firestore scales in other ways too. Being built on App Engine from the start, Dialpad has been leveraging Firestore from its earliest forms. Over the 14 years, our database has grown from bytes to petabytes. That in itself is impressive. Not many databases can grow to that scale. But even more than that, we never really designed it to achieve that size. There were never schema design meetings about reaching petabytes. Never had to rebalance or shard our database to grow to that size. And we never had a planning meeting with the Firestore team about building it to that size. As we grew, it grew and it continues to grow. This graph highlights some inflection points of our data storage over the years as we enabled AI features. In 2018, when we first turned on AI transcripts. And in 2022, when AI Recaps was launched. Again, the Firestore system just worked and grew bigger as we asked of it. Over those 14 years, we also have never had a database administrator on staff. Just software engineers building new features dreamed up by our PMs to meet customer needs. Each demanding more from Firestore. Firestore has been a critical aspect to our success. And although I will give the Firestore team a lot of credit for that, there were things that we did as well to help achieve it. First and foremost was we built to its strengths. We designed our schema and application flows to avoid queries in the most critical paths. Preferring lookups over queries because of the performance differences. That meant we had to be careful to choose key names and IDs that could or were already being shared between systems. So that our serverless instances could do lookups instead of queries. Here you see that our lookup volume is more than 20x the query volume. Like most other applications, we still leveraged a caching layer in front of Firestore. The original ORM provided by App Engine allowed us to tie this in effortlessly. And we leveraged a search platform, App Engine full text search originally, now Elasticsearch, for the most rare and complex queries, keeping our indexes limited. And with the announcements from the Firestore team today, we are eager to explore how we might be able to leverage new query engine to simplify and evolve even more. Firestore also works well with the other GCP services. Due to limited querying ability for business analytics, we had to export aspects of our Firestore database to BigQuery and other third party time series databases. This allowed our data analysts and engineering teams to better understand our business as a whole and build new customer facing analytics features. Building a change data capture pipeline was especially challenging in a serverless environment because updates can be processed out of order and analytics needs to be accurate. Customizing the ORM further to produce client-side diffs, we were able to connect Firestore updates with BigQuery, leveraging cloud logging and PubSub as transports, and use the Firestore version ID to maintain item potency. Working with the Firestore team further, they developed an event arc-based export tool from Firestore to achieve similar results without the need for client-side diffs, which we are now looking to utilize. Firestore has allowed us to build our scalable, real-time, AI-powered customer communication platform, and we are excited to continue that journey with Firestore and incorporate the new querying features. And our finance team is particularly excited to enable those committed use discounts. Min, back to you to wrap this up. Thank you. Great job. Thanks, Dana. Can we get another round of applause for Dana? We appreciate the partnership over the last 14 years, and I have been so impressed by the growth of Dialpad's AI-centric communications platform. We're now hitting the home stretch. At Google Cloud, we understand that a database is not a one-size-fits-all. And that's why we give you the freedom to choose between engines. Furthermore, Google's AI-ready Data Cloud is your platform for innovation in both data and AI. Today was just a teaser, but we know that you want more. If you'd like to get started with Firestore, we recommend that you visit our product page. If you'd like to get some in-person help, we're going to be here after the session for any questions and answers. Thank you again, and please remember to fill out your surveys. And make sure that you smash that five-star button. Thank you. Thank you. Thank you. Thank you. Thank you. Thank you. Thank you. Thank you. Thank you. Thank you. Thank you. Thank you. Thank you. Thank you.