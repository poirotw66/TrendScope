 Darla Lewis Hello, everyone. My name is Darla Lewis. I lead a team at Google that focuses on cultivating a thriving development ecosystem around our core programming languages. Platform engineering are at the heart of what we do every day as we aim to improve the developer experience, drive long-term sustainability, and combat software entropy. We do this by developing widely used libraries that help power our platform, evolving and disseminating best practices, and building infrastructure to drive large-scale change across our code base with a keen eye towards code health. Some of the very things that we're going to be talking about in this talk today. I'm excited to be here with my PM partner, Leah, to share this time with you all. Leah Rivers Hi. I'm Leah Rivers. I'm the director of product for software foundations at Google, where I get to focus on how technology and culture work together to make Google work better for everyone and at scale. I was working at a farm when I first started building on the cloud. We were migrating on-prem services to the cloud, and by on-prem, I mean the barn and also the garage down the road. I was learning to configure and operate cloud infrastructure so that we could more reliably and efficiently run algorithms about things that really matter to our business, like carrots, beets, and potatoes. And it turns out, some of the most powerful insights about platform engineering for Google innovation and scale are also as practical as potatoes. We face a ton of complexity every day, but there are some very practical insights that create huge value for us. We want to share those insights with you. So Darla and I focus on platform engineering to support Google developers across all of Google's product areas in an area called Core. In Core, we partner with Google Cloud on platform engineering strategy and investments. And Google Cloud helps us to re-envision and improve platforms within Google, and together we take Google's internal capabilities and package them up for use by cloud customers. In platform engineering, clarity is really important. There's a saying that a problem well-defined is a problem half-solved, meaning it's already half-solved. Solving the right problem can save a ton of work, and it's a practical boost to velocity and efficiency when we can do it. So one practical thing we need to do is remember the obvious things about how software development relates to business goals. In our day-to-day, we care about Google user experiences. We care about developer experiences, operational excellence, open source collaboration, and so many other really important aspects of success. And amid all these priorities, we still need to work towards the business goal, which is to maximize business value with existing resources, achieving acceptable quality, with sustainable costs. Seems obvious. It's easier said than done. So keeping this goal top of mind helps us to prioritize and work smarter, not harder, where we can. Shift Down is our platform engineering product strategy, both inside Google and for Google Cloud customers. Much like shifting left to catch things earlier in the development lifecycle, we want to shift down, providing support to scale software systems from initial idea to large-scale business as effectively and efficiently as possible by embedding solutions to common problems in our platform. Shift left helps us improve the developer workflow when a problem space is evolving where we're still figuring it out. Shifting left helps us to iterate and that increases the clarity on what problems we're solving and that reveals options where we can shift down. We shift down when we've identified the problem to be solved and we can solve it in a reliable, reusable way across products and businesses. And doing this gives us a double benefit. One, the problem gets solved so developers can focus on solving other problems. This helps us accelerate innovation. And two, we can solve it once, centrally, and so the Google-wide cost of solving that problem can be significantly reduced. This helps us sustain growth. Since understanding the problem matters so much, let's take a minute to set the stage for the problem that Shift Down solves. Imagine you're a developer starting a new role at a large software company. You've onboarded and you're ready to make your first change. Let's say you're adding a small new feature. When your change is deployed, it might reach millions of users worldwide. It might need to meet regulatory requirements across geographies and customer segments. It's going to need to achieve some kind of quality bar for things like reliability, performance, accessibility, and security. How do you, as a developer, account for all these quality attributes in addition to creating user value with your feature? How do you even understand the full set of requirements and risks that your change entails? Let's just say you could fit all of that in your head. How would you know if you've effectively addressed it in your code? And how would you know if you've done it when you deploy? And what about after you deploy? And what about over time? Just implementing, understanding, and sustaining the level of quality for any one feature is, at this type of scale, is beyond the reach of any one person. So this would be an impossible challenge for any developer if starting from zero. And that's where platform engineering creates value. Platform engineering helps developers achieve these goals and Shift Down eliminates entire classes of problems so developers don't have to think about the implementation at all. Shift Down is super practical and it's also a familiar idea. For many decades, software developers have been identifying stable problems and solving them in reusable, reliable ways. For example, there's all kinds of stable subproblems that are solved by libraries. Regular expression matching, random number generation, just a couple obvious ones. We're just applying that same technique at scale to the scale as we can possibly muster. It's practical as potatoes. We shift down to durably solve the repetitive parts of development so we can move on to new areas and new problems. Development teams can focus more on feature development and product innovation and folks like Darla and I get to innovate by finding new ways to shift down. That's right. All right. Before we dive into too much more detail, let's talk a little bit about what we're going to be covering in today's session. We've structured our time together around three main areas. We'll start with platform engineering and Google's journey where we'll explore what platform engineering means, especially in the context of Google's experience in building internal platforms and our evolution in this space. Then, Leah will walk us through practical insights and observations. Here, we'll share some key learnings we've gathered along the way and focus on actionable insights that you can apply to your own organizations. Lastly, we'll wrap up with some key takeaways highlighting the main points that we've discussed. So that's our roadmap for today. I hope you'll find this session informative and insightful and let's get into it. For those who might be newer to the concept, platform engineering has gained significant traction recently, as highlighted in various reports. However, it isn't a completely new idea. Google has been on this journey for quite some time, learning valuable lessons and refining our approach along the way. We want to share with you some of the foundational principles that have shaped our understanding. Let's talk a little bit about the platform. Let's talk a little bit about the platform because it's more than just the underlying technology. It's a socio-technical discipline. It brings together tools, processes, and importantly, people that helps drive innovation in significant ways. Think of it as a curated and integrated collection of capabilities. These are not just random tools thrown together. Rather, these are carefully chosen to meet the specific needs of our users, our internal engineering teams. The platform also acts as a cross-cutting layer within the organization. It's not siloed. Instead, it provides a consistent and coherent experience for accessing essential capabilities. So how does a platform drive innovation? A well-engineered platform contributes directly to increased velocity and productivity by significantly improving the developer experience. By providing end-to-end golden paths that decrease cognitive load, we empower our developers to focus on delivering value rather than wrestling with undifferentiated complexity. And perhaps more importantly, a strong platform enables accelerated product development by providing the necessary foundations, removing friction, and improving observability, giving us insights into our systems. In essence, platform engineering is about providing the right infrastructure, processes, and tools to power our development process, unlocking significant benefits in terms of speed, scale, and innovation, ultimately driving tangible business value. To build such impactful platforms, there are several components that we've learned are essential for success. First is embracing the mindset of platform as a product. This means being deeply focused on the needs of its users, establishing feedback loops to understand pain points, requirements, and how the system needs to evolve. By adopting a product-centric mindset, we ensure that the platform provides relevant capabilities for the most common use cases. Second, developers should be able to independently access platform capabilities. This means a platform should offer its capabilities on demand with minimal manual intervention. This is essential for empowering our developers and allowing platform teams to scale efficiently. This can be achieved through various interfaces, such as web portals, APIs, or command line tools. But this autonomy enables developers to get what they need when they need it, accelerating their workflows. Third, it should hide the underlying complexity of the infrastructure through well-defined abstractions. By providing the right level of abstractions, we allow developers to focus on building great features for their products without also needing to become experts in the underlying infrastructure. And finally, it should provide safe defaults and enforce best practices that are aligned with SRE principles, such as automated deployments, monitoring, and security controls. By focusing on these key components, we can build a powerful internal platform that significantly enhances the developer experience, boosts productivity, and drives innovation within our organization. Now, let's connect the idea of platforms with development ecosystems. Platform engineering serves as the bedrock upon which development ecosystems thrive. Think of the platform as the underlying infrastructure and services, the essential building blocks. The development ecosystem, however, is much broader. It is the arrangement of software, tooling, and operations that we use to develop, deploy, and scale software products. The connection we want to make here is that controls, such as ensuring quality, security, and others, are achieved through a combination of robust platform engineering and intentional ecosystem design. Platform engineering allows us to embed controls directly into the infrastructure, while intentional ecosystem design dictates how those controls are leveraged and which of those controls are necessary at different stages of the development lifecycle. So, Leah will dive deeper into these controls a bit later. Building on this idea of controls, let's talk a bit about how they interoperate within our ecosystems. Unsurprisingly, building development ecosystems requires trade-offs, a central one being the balance between abstractions and coupling. If you remember, we talked about abstractions just a little earlier. Well-defined parts here represents how we use abstractions to provide developers with a robust reusable building blocks. These building blocks offer a number of benefits. They simplify complex systems, making them easier to reason about. They represent consistent and well-tested components that help manage risk. And they promote reuse and standardization for cost control, just to name a few. The development ecosystem is about taking those abstractions and coupling or connecting them in such a way that it creates something that is greater than the sum of its parts. The interplay between abstractions and coupling allows us to achieve emergent properties that we call quality attributes. So, what are these quality attributes that we aim to assure with our platforms and our ecosystems? They are the non-functional requirements that define emergent behavior in our system. They are the properties of the system as a whole that would be incredibly difficult to achieve with isolated components alone. They are not about what the software does in terms of features, but rather how it does it. As you can see here, there are many quality attributes to consider. I'm not going to read them all. And in fact, this is not an exhaustive list either. There are many other quality attributes that might be important depending on the specific needs and context of your system. The takeaway here is that platform engineering plays a vital role in enabling and enforcing these quality attributes at scale. Here's a way to think about the difference between features and quality attributes. You can point to the exact spot in your code base where the add to cart feature happens. But it's much harder to point to the exact spot where reliability happens. Let's look at a fairly common refactoring example of how shifting down can become a superpower. We've all had to deal with a scenario where an API has been deprecated and we need to migrate to something else. Think about how we approach such refactorings at different scales. At a smaller scale, imagine the method you want to migrate from has only a handful of uses. The most efficient way to do this is likely just to make those changes in your editor. It's a manual task that is fully in the hands of the developer. Now, what if that method is used thousands of times? Even at that scale, manually editing each reference becomes impractical. In this case, you might use some custom scripting with local compiler-based refactoring. This still requires significant effort to both create and execute. But what happens when you operate at a scale even larger than that, such as Google's monorepo? Imagine you have to make a change that touches hundreds of thousands of references. How much effort would that take you? How much of that effort would be manual? Trying to manage large-scale changes and refactorings this way becomes challenging and risky. This is where the power of embedding capabilities into the ecosystem truly shines. We're all too familiar with the pain of migrating widely used deprecated APIs. Inline.me is a deprecation mechanism for Java that uses annotations to allow automated tools to clean up old APIs. My team has built automation around this as part of our large-scale infrastructure. This automation just runs in the background, identifies usages of the annotation, finds all the references, and generates the necessary code transformations. Then it runs the test and sends the changes out for review. Once the change is approved by the reviewers, the CI-CD process picks up the change, validates it, and propagates it all the way out to production. The developer only had to specify what to change. Everything else is handled by automation. This embedded capability fundamentally shifts the responsibility for migrating from individual developers to the platform itself. But there is more. Once the tooling is in place to automate one class of refactorings, the ecosystem can be extended to support other types of code transformations. So similar mechanisms can be used to automate things like changing function signatures or updating to new language standards, for example. To give you a sense of magnitude, our large-scale change infrastructure has enabled single refactoring efforts that have touched millions of lines of code. This is the kind of platform engineering work that we do. Identify stable problems and automate them, shifting them down into our platform. Okay. Now that we've talked through some of the core concepts, let's share some of the insights that we've learned. All right. So one practical consideration is, how much does it cost to shift down and is it worth it? We want to create platform value across a broad range of business needs. And so we need a tool to help us create shared understanding and make good decisions. So, this is a map or model that we have found useful to get better at matching platform investments to our business needs. Better maps, better models mean better thinking and better decision making. So, on the Y-axis, we look at the impact to the business if a mistake is made, basically the penalty for failure. And on the X-axis, we look at how the ecosystem can control quality attribute and outcomes. So, Darla talked about quality attributes earlier. We focus on quality attributes for two reasons. First, quality attributes are where much of the software business risk resides to meet regulatory requirements, service level agreements, to control costs, or influence velocity. And second, quality attributes are emergent properties of the system as a whole, and they're deeply rooted in architecture. Consider the feature of displaying a user profile. You could build this into almost any software system, whether it's one big application or a collection of smaller services. But now think about how quickly that profile loads or how secure the data is. Those quality attributes aren't just added on the way you can add on a feature. Quality attributes are deeply rooted in the underlying architecture. And a well-designed architecture might allow for faster loading of different profile sections while also dictating how the data is protected for privacy and compliance. So, while the feature of displaying a profile is adaptable and it could be implemented in all kinds of different architectures, the architecture fundamentally determines the achievable quality of that experience. Okay, back to our map. Across the center, we have the ecosystem effectiveness zone, where the business risk matches the cost of controls and the cost of the ecosystem. To the upper left, we have the zone where development is happening without the desired degree of central platform control. And teams here are responsible for managing their own risk locally with a lot more manual effort to assure quality. And here is where we want to identify new ways to provide central assurance. And this zone gives us strong information about where to shift left and where we might be able to shift down. And to the lower right, we have the risk of too much constraint or not enough shift down. Sometimes we talk about this internally as the broccoli zone. We even have memes about a broccoli man character who represents the challenges and pain points in the developer experience that emerge when there's too much ecosystem constraints for the job at hand and not enough shift down. And I'm not sure why it's broccoli. It definitely predates my arrival at Google and is in no way related to my farm experience. So, we need to continuously improve our ecosystems because the broccoli zone challenge is real. And it's why platforms and ecosystems need continuous improvement. And finally, you'll notice that we have this idea of types along the x-axis. These help us to talk in more detail about different ecosystem design techniques, where to apply them. It's worth noting that this is not a maturity model for ecosystems. The best type of ecosystem is the one that best supports the needs of your business. And these types range from zero, which you might refer to as like YOLO, you only live once. It's like self-directed use of a wide variety of resources for tinkering and exploration. All the way up to type four, which is more what it looks like in the example Darla shared, where we can use automated tools to clean up existing callers of deprecated APIs across our internal type four ecosystem. We call this type assured. And it lends itself to business problems where an opinionated, vertically integrated stack is continually tuned to maximize value for specific business models, with specific quality attribute needs, and specific architectures. So, this map helps us take a risk-driven approach across a diverse landscape of business needs. For a given decision or problem, we can look at where a system is on the map today, and we can talk about where we think it should be, and just the clarity there can become a superpower. It's common to find that different stakeholders would imagine the problem and also the solution on very different parts of this map. So, agreeing on the current state can be hard work with big payoffs. Another obvious and super helpful consideration in Shift Down is that it impacts the developer experience in a different way than shifting left. When shifting left, there's a change in how or when a developer does a task, moving things earlier into the workflow. When shifting down, we change what work a developer does and what they have to pay attention to. Shift Down is a change in developer focus and responsibility. Overall, as a software system is successful, developers have a lot more work to do related to quality attributes. And shifting down changes the tasks that the developer is responsible for, and we use things like golden paths that solve these problems in the architecture. This is also a familiar concept that you already know, and we're just applying it to our internal ecosystems. Google Cloud has a shared responsibility model that spans infrastructure as a service, platform as a service, software as a service. And in a similar way, the concept of these ecosystem types is useful to us internally to describe the different levels of platform support and ecosystem controls that our developers are best helped by. From a product management perspective, this presents an interesting challenge, too. It's easier to measure changes to the workflow and shift left. But the real magic and opportunity of platform engineering is experienced in the absence of problems that would otherwise be solved in the developer workflow, and in the costs that are avoided, and the improved quality attributes at scale and over time. That's a lot harder to measure. And so it can be a lot harder to prioritize when it's being prioritized against shift left and workflow optimizations. So to recap, the practical insight here is simple. Shifting down changes the work that developers are responsible for, and that changes how we support developers. And we also have to figure out how to measure and prioritize shift down in combination with shift left. In development ecosystems, shared fate is one of those deliberate design principles in our ecosystems. Ecosystem components are interconnected and interdependent or coupled. And this creates a situation where the actions of one component can impact the whole system. Shared fate has the great benefit of economies of scale. For example, a large-scale continuous integration system might be able to provide global low-latency correctness signals. And the risk from shared fate is tragedy of the commons. A single developer has an incentive to ship just a little bit less correct software to get a little bit faster in order to maximize local velocity, but weakening the system's global correctness signal overall. And this can accumulate. If any component has a bug or is broken, it affects all the reverse dependencies. So shared responsibility is essential for ecosystems to be in that effectiveness zone from our map. Ecosystems are constantly changing. We need to measure improvements so that we can tell if we're actually making progress versus simply churning or regressing as we change things. And one of the great unsolved problems for software companies is the inability to directly measure the business value of a change to a software workflow or platform. A helpful way to look at it is to divide up the problem space. Within any given workflow, there are three distinct process types. Develop, deploy, and operate. Each process adds a unique type of value and is measured in a very different way. That insight alone helps us to measure better, even if we don't have that crisp, clear measures of success that user-facing products do, like, you know, revenue. For example, nearly all feature development work in deploy could be theoretically unnecessary overhead. If a company can reduce engineering involvement in deploy and reinvest that time in develop, that creates value. Actually, a lot of value. For feature developers, taking time from deploy and reinvesting it into develop is a huge boost to developer capacity, even if we can't measure that boost directly or immediately in revenue. The more a software system succeeds, the greater the need for both feature and platform development. This is a challenge of scale. And the tensions between feature and platform often feel like hard trade-offs or polarities. A platform values uniformity for efficiency. And a feature development values flexibility for experimentation. Platform development values analytical power for observability. And feature development values expressive power for exploration. Within a team, switching between feature and platform is more costly than simply the cost of context switching. Switching between tasks. It's actually switching between two fundamentally different beliefs about what good software looks like. Without an intentional shift down strategy, it's hard to maximize value from both feature development and platform development. And we don't want the average of these two. And we don't want to trade off one for the other if we can help it because it creates significant limits. So we can find ways to incentivize and value both feature and platform development. To increase the impact of both. And this creates more capacity to innovate and grow with the same resources without sacrificing quality or increasing costs from our goal. It can truly be a differentiator. This tension between feature and platform development is felt in our day-to-day experience in software development across virtually all levels and contexts. It's really the change in software between the simultaneous need for both expansion and consolidation. This strategy, along with our map and our measures, helps us make decisions that systematically minimize or eliminate limits and trade-offs that affect our growth. And this tension of feature and platform is interesting. It's also instructive. It's a guide about where to improve and how. For example, you might ask, where do these hard trade-offs between feature and platform values feel like they're most holding you back? Look there and see how much shared understanding and clarity you have. Maybe you can shift down if you can solve a problem that's well understood and solve it in a reusable, reliable way. Or is there maybe a policy or a practice that could be integrated into your culture or shared responsibility to improve incentives? Or potentially there's an option to shift left in the developer workflow. All of these are ways that you can use a shift down strategy to create new capacity for innovation and growth in big ways and in small. And that's practical as potatoes. I do like potatoes. All right. As we come to the end of our content, let's quickly recap some of the points that we discussed. First, we emphasized that quality attributes emerge out of architecture. This means that a risk-driven design is crucial for building assurances for qualities like security, reliability, and performance directly into our platform. Next, we discussed shifting down as a core principle. By embracing the polarity between feature and platform development, as Leah talked about, we can empower our development teams by providing them with robust underlying infrastructure and services. Then, we highlighted that shared fate enables economies of scale. But it also requires shared responsibility. It's not just about the platform itself, but what the people in the ecosystem do that determine success. It's a socio-technical discipline. Lastly, development ecosystems are constantly evolving. So, we must embrace a mindset of refinement and adaptation. Understanding how platforms influence business value gives us insight into how to improve and evolve. So, to close us out, by designing for quality attributes from the start, strategically embedding capabilities into our platform, fostering a sense of shared responsibility, and embracing continuous improvement, we can build an effective development ecosystem that drives business value. These are some of the insights that we've found to be useful, and we hope that they can be helpful to you as well. Thank you. Thank you.