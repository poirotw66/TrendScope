 Hello everyone. Welcome to our session today. Hope you are having a fabulous time so far on the first day at Cloud Next. So before we get started, really quick, show of hands if you're familiar with the graph database. All right, we have some over here. And show of hands if you think it's pretty cool to have BigQuery support graph. Awesome, we have a few dozens in the audience. Thanks for supporting this. For those who didn't raise hands, hopefully after the session today, we'll be able to change your mind. My name is Candice Chen. I am the product manager from BigQuery. And joining me on the stage later today is Yun Zhang, who is our engineer manager. It's our great pleasure to have two very special guests from BioCortex. Nick Sharma, CEO. Mo Alamari, CTO from BioCortex to share with us about their user experience. So we're going to first talk about why graph. What are some of the common use cases for using graph across the industry? What can you do with graph query support in BigQuery? We'll show you a demo on using graph for fraud detection. Then we'll invite BioCortex to share with us how they were able to leverage graph technology to discover drugs that can potentially cure cancer. And at last, we'll wrap up and leave some time for Q&A at the end. Data is only meaningful if we know how they're interconnected. If we look at the world around us, you can find many types of data are actually mapped in graph. Graph have been used to solve key questions across the industry. Take retail as an example. Customer purchase your products. They visit your website. They file a ticket. Essentially, you want to build a customer 360 view so you can provide more personalized product recommendation. In finance, you see one account transfer money to another account. And maybe after 10 hops of transfer, the same amount of money is going back to the same starting account. So you want to build a finance graph so you can find those suspicious activities for fraud detection. In social media, based on who you know, who follow you, you want to build a social graph so you can find who are the most influential people in your network for better audience targeting. In healthcare, you want to find how different chemicals interact with each other. One chemical modify a protein. A protein can lead to a new disease. So you want to essentially build a chemical graph so you can use this information for drug discovery. And the list goes on. So today, you model your data in a relational table using primary key and foreign key. And this is how we are taught in school for more than four decades. It has its own benefits. But what if we take a step back and model our data in a graph? Graph. Graph, by its nature, is so much easier for our brains to process information, to understand, to visualize, and to explain in a much more intuitive way. Graph is great at finding hidden relationships. Now, you can answer questions like, find John's friends of friends. Find me all of the connecting flights or shortest flights from here, Vegas, all the way to Paris. To do some what-if analysis. If one system is down, what does it mean? What are the downstream dependencies for the rest of my system? So, now we talk about the benefits of graph. Why shouldn't every company be using graph today? So, we talked to a lot of customers like yourself and learned that they are faced by three major challenges. The first one, data silos and a maintenance overhead. So, most of the time, you have to move your data from BigQuery or a single source of choose to a standalone graph database. This can introduce issues like data silos, data duplication, and data drift. So, by the time you might be happy with your prototype and ready to productionize it, the data is no longer fresh. And then your business requirements probably have changed at that point of time. And the second is performance and scalability concerns. So, it usually works pretty well if you start with one single node, one customer, to provide product recommendation. But if you want to scale it to millions of customers, it just doesn't work. And then lastly is lack of graph expertise. At the end of the day, you still have to learn, manage, set up, configure, and learn about an entire new framework to make the database work. So, at Google Cloud, we took all of your feedback into consideration when we were thinking about this problem space, trying to solve these challenges. So, last year, we actually launched Spanner Graph, which is already GA'd. You have native graph capabilities inside Spanner. So, Spanner is our fully managed transactional database. With Spanner Graph, it's optimized for online and operational graph use cases. So, take fraud detection as an example. As one customer is about to swap their credit card, you want to be able to identify if this is a suspicious activity and stop the transaction right there before it happens. But what about batch and analytical graph workload? What about not only curious about one single customer provide recommendation, I want to actually find their transfer activities across millions of accounts? What if I want to go back point in time and find their transfer account ownership five years ago? So, this is where BigQuery shines. And that's why we are here today to complete the analytical side of the chart. It's our vision to have a unified graph solution. We can satisfy the full needs of your graph from operational to analytical with a unified graph modeling, graph query, and graph visualization experience. So, now let's take a look at how exactly it looks like to have BigQuery support graph. So, the approach that we are taking here is probably very different from what you see in the market. Instead of you taking the data out from your single source or choose to a standalone graph database, we are bringing graphs to your BigQuery data at scale. So, now you can map your relational table to graphs on one single copy of data. Now you can manage graph and tables side by side with full interoperability. This is all powered by BigQuery's large-scale infrastructure that we've been optimizing for over a decade. With BigQuery graph, now you can have built-in graph experience. You can write graph query language, GQL, to traverse relationship in your data and find those hidden relationships. And GQL has also become part of the ISO standard since last year. You can also mix your graph query with SQL, which allows you to leverage the best of both worlds. The familiarity of SQL, as well as the expressiveness of graph query language for pattern matching. One of the key benefits of having graph support in your data warehouse is you can now leverage all of the capabilities that BigQuery has to offer and the entire ecosystem. Now you can do full-text search, vector search, on top of the nodes and edges that you define in a graph. We all know a picture is worth a thousand words. And so is a graph. Now you can show those insights in a graph format to your customer, to your stakeholders, in a much more easier to understand and intuitive way. And this is all backed by BigQuery large-scale analytical engine that can help to scale your graph workload to billions of nodes and edges. Now you have your graph already created in BigQuery, you can leverage Spender Graph for online serving that gives you up to millisecond latency. And then you can achieve all of this using a unified graph interface. So how does it work in BigQuery? In three single steps. First, you create graph schema on top of your relational data. You write graph query language to traverse relationship in your data and find interconnectivity. And thirdly, you visualize graph results in a notebook. So now let's dive deep into each step using a finance graph as an example. First, imagine you already have your table stored and created in BigQuery with information like account, person, and some other tables. Now here is the magic. Now you map your table to graph by writing a DDL statement, create property graph, to define this finance graph. Now you specify what are the nodes that you are interested in. So I'm creating two nodes here, account and person. Now I want to specify what are the relationship or edges among those nodes. So the first is transfer, representing transfer activities from account to accounts. And next one is ownership relationship, representing one person, only one account, or multiple accounts. And this is how it looks like for the graph schema that we just created. Now that you already model your data in graph, it's time to write some graph query language to find some interesting insights. So in this example, what you're trying to do here is find a person whose name is Jacob, the account that he owns, and the loans that he repays from those accounts. As you can see, now you can express this logic in such an easy way, and then you don't even need to write any multiple joins, or even need to understand what's the underlying structure of your data. And in a more advanced use case, you can combine vector search with graph in one single statement. In this example, I have a suspicious account with account ID 102. And I'm curious, what are some other similar accounts that might be suspicious so I can do further investigation? So I'm using embedding calculation together with vector search to find those other similar suspicious accounts. Then in step two, I can find what are the transfer activities for those suspicious accounts up to six hops of transfer. Now you can see with this capability, you are able to have a great starting point to do your further investigation. Otherwise, it will be much more hard to do and even hard to explain how you got here. We talk about BigQuery graph interops with Spanner graph. So in this use case, you have some real-time data stored in Spanner, highlighted in green, with information like account, customer, transfer activities, etc. And then you have some historical information stored in BigQuery device and then login information. So what you can do now here essentially is create a virtual graph on real-time data from Spanner and historical data stored in BigQuery without even the need to move the data that you already have in Spanner. And this is all backed by data booths, which some of you might be familiar with. Now it's time to have some fun. Now let's visualize all of the graph results in a notebook. You can start to explore the neighborhood information, the node connectivities, all inside BigQuery Studio notebook. It's also available in Colab as well as open source Jupyter notebook. Besides the native graph visualization support, we also know you might have some specific needs, which require specialized tools. So we have also closely partnered with companies like Kinevis, Graph History, G.V, and Linkurious. So now you can start to connect your BigQuery data into this platform and start visualizing them today. Now let me welcome Vinh to join us on the stage and show us a demo on using graph for fraud detection by putting everything we just discussed together. Thanks, Vinh. Thank you, Candice. Hi. My name is Vinh. I'm the engine manager for BigQuery SQL team. But for the purpose of demo, with a blink of eyes, now I'm turning into an engineer who's working for a bank on fraud detection. And don't let my boss know that. So for my day-to-day work, before BigQuery graph, we're having some BigQuery tables, like account, loan, person. We're also having some transaction log, like account repays loan, account transfer to another account. So in order to get help from BigQuery graph, let me first create a graph schema over the tables. After running the query, here's my graph schema. We're seeing person owns account, and their account can make transfer to another account, and the person can use his account to repay loans. The data set in a big picture look like this. A lot of person loans and their accounts. And if I want to view the web of all the transfers, I can run a different graph query. Now I'm looking at a web of transfers. Remember, now my day job is working for a bank on fraud detection, and my day opens like remembering in Candace Slides. She mentioned someone like Jacob and a suspicious account, ID 102. Okay, two things to look at, but one thing at a time. So with this graph query, I'm pulling the financial life of the person Jacob. To recap a little bit on the graph query, very naturally, we're having a person named Jacob who owns accounts, and he uses his account to repay loans. And we also care about whether he uses his account to transfer to other accounts. So if I run this query, now I'm seeing the visualized financial life of Jacob. Again, the blue dot here is Jacob. If I click here, you can see Jacob himself, and Jacob owns one account. He used his account to repay loan two times. It looks normal. And he transferred to three different accounts. One, two, three, which also looks normal. Hmm. So could there be hidden relationship between the person Jacob and the other? Remember the second thing, the account ID 102? So if I tune my graph query slightly to say that I want the transfer destination to be the account ID 102, and I care about not only the direct transfer, what if I'm curious about within 10 hops, the funds lands in the account 102. Maybe I can find some hidden relationship, and this is what the graph queries gives me. Blue dot, Jacob. Account. Jacob's account. Now I remember Jacob made three transfers to three different accounts, while this one is the suspicious account 102 directly. And I also noticed that Jacob also made an indirect transfer to 102. And maybe more interestingly, the third account that Jacob transferred into has a ring of transfers. And some funds ends up getting into this account 102. So it looks like Jacob does have something to do with this suspicious account 102. Now I'm thinking, Jacob may not be the only person who's related to this suspicious account. So I tune my query a bit further. So I just remove Jacob's name from the person. So now I'm looking at all the persons who made the transfer to this account. And I want to list the person's name, their account ID, and how far away they are from the suspicious account. By how far away, I really mean number of hops, which is a little bit hard to think about. But there we go. I'm pulling out a table of name, account ID, and how far away. No surprise, Jacob's here because he had one direct transfer to the account ID 102. And we're seeing Jacob listed twice. Right? But probably, I don't need a table with duplicate entry. So what if I add much any shortest? So I only care about the shortest transfer path. Then I'm getting a cleaner table. Yes, Jacob's still listed as the one hop transfer because that is the shortest path that he has with account 102. Hey, this is a really long table. I guess I would probably spend my whole day on this table investigating each of the accounts. But think about it. This is the AI era. My bank also have embeddings on each of the accounts. So the embeddings is created by the account's activity or behavior pattern. Right? The machine learned technique to generate this feature set of embeddings. So that I can do a vector search to find the top five similar account to account ID 102. And I'm storing it in similar IDs. Then in the later half of the query, I'm able to visualize the transfer activities of the similar IDs. This is how it looks like. Hmm, not that useful. Where's even account ID 102? I cannot see it. But what if I change to left to right? Layout. Then there's something stands out. It happened to be account ID 102. So it turned out if I visualize all the similar accounts and their activities. They are somewhat related to this suspicious account. Something's not right. And kind of AI rocks. All right. Lastly, I think it makes sense to inspect the audit information for the related accounts. So, but my bank has account audits as a separate BigQuery table. It's not a part of the graph. If you remember, the graph has only person, loans, and accounts. But I'm not worried about this at all because I know that I can join this graph table with the BigQuery table. and within graph table operator, this is the familiar graph query that I've been playing with. So if I run this query, I know that now I'm blending the graph data with BigQuery table. I think I'm confident to say that with this capability, my graph can interoperate with the other great capability that BigQuery has. And now that we are having this audit logging, quickly peeking into this. So this account, ID 489, has password updated twice. API key revoked. Hence, the account was even deleted by the user. Something's not right. All right. To recap, I feel for fraud detection, I'm able to use the graph versus without graph. I'm able to use graph to quickly build intuition by visualize the data, by quickly write the graph query. I'm also able to productionize my intuition into a table of data so that I can check against my intuition over a large scale of data. I feel my life is so much easier with BigQuery graph. All right. With another blink of eyes, I'm turning back into BigQuery engine manager I hope my boss didn't notice my day off. All right. Can we switch to slides? So, so now that you have seen a demo on fraud detection, graph have many, many other use cases. like drug discovery. Now, let us welcome Nick and Mo on stage to talk about their story. Thank you. Thank you. Thank you. Thank you. Thank you. Well done. Okay. Good afternoon. So, thank you to Candice and everybody for the invitation to talk about what we do at Bicortex. Now, we are an unusual company and maybe, just maybe today, after this talk, you'll look and think slightly differently about bacteria and you may think slightly differently every time you take a medication. So, so what am I, what am I, what am I talking about? Well, about 150 years ago, we, we didn't, we didn't know that bacteria existed. You know, we had no idea about it. About 70 years ago, we, we discovered a way where we could interrupt them, i.e. penicillin. And today, I'm telling you that there are, there are bacteria that, that actually live within cancer, tumors, that determine whether a patient responds or not. So, and when we talk about response, we talk about, you know, figures about 70% do not respond or 88% do not respond. And what we're saying is that, that's partly due to those bacteria. Now, why does this matter? So, at this time, so my background is that I'm an MD, PhD, at this time, I'll guarantee there is somebody driving back from UCLA in their car, we'll call her Miss X, she's likely to be given a diagnosis of breast cancer. She does not know whether she's going to respond to that medication. Her family do not know whether they're going to respond. The only way is you roll the dice, you know, we're in Vegas, you roll the dice, you wait six months and you see whether she's going to respond. Now, imagine a situation where we could determine whether those bacteria would interfere and imagine a situation where we could say, actually, you know, let's not try that because, because you live in LA, the bacteria are going to interfere, let's use drug B. Obviously, it would be very different if they lived in New York, probably, probably, from my accent, I'm from the UK, so the bacteria in London are very special and very different, yeah? Okay. Why is there this deep connection between bacteria and humans? One of the fascinating things we all know about mitochondria, they're in our cells, they're little powerhouses, anybody who does any endurance sort of racing, it's all about getting your mitochondria to do things. Mitochondria are ex-bacteria. They hitched a ride about 1.5 billion years ago, so we are partly bacterial in many ways that we do things. Now, what we do as a company is that we test, fail, and iterate in silico, so we run in silico trials and emulations, and we've built a massive knowledge graph of about 37 billion connections, and we do this so that when we try drugs in patients, we have a better idea of whether they're going to work or not. Now, what we've done is that we've built an in silico representation of the environment within a tumor. Now, bacteria are special little things, right? They're constantly evolving, they're constantly changing, and the problem is is that it's a graph problem in many ways. They produce metabolites, they interact with the other metabolites, there's lots of them, and so they're constantly changing, and it's not just about does bacteria A produce metabolite A, it's whether, you know, the 10th metabolite down the line is the one that's going to interfere with Miss X's drug, and what we're trying to do is trying to understand that environment, but the challenge is this is a mass problem. This is why I'm sort of joined by my co-founder, Mo, that this is a near-infinite search space. Mo? Thank you, Nick. Hi, everyone. I'm Mo Al-Omari. Really pleased to be here. First of all, I want to say thank you for the Google Cloud team for having us, and I want to say that I could not be happier with the technology development journey that we have been with the big query graph team so far. I mean, Candice, Yuan, Michelle, and the rest of the team have been absolutely great at supporting us, and it has been a very fruitful journey as we will show you later today. Right, so let's get right into it. So, spoiler alert, the problem that we are talking about here is a graph search problem. Obviously, it is, and in terms of the, just before that, on the infinite search space, if we look at the implications of solving this graph search problem, it's actually quite profound. As Nick highlighted earlier, this carries the potential of giving us an understanding of cancer that has never been seen before, and I mean at a fundamental level looking at the biochemical way of how cancer operates, which is truly astounding because that would really fuel our quest into curing cancer. And now, is this just about cancer? Not quite, really. I mean, this is where it becomes really exciting. This could fundamentally change our understanding of many different disease area, but cancers remain the beachhead for us here at BioCortex, as Nick have mentioned before that. And to help understand, given that there is a lot of excitement, and, you know, this has such a profound way of changing our understanding of many diseases, why is it so hard to do? Well, because it's a near-infinite side space. There exists, as in humanity estimates, that there exists about 10 to the 60 potential chemicals out there, and that is a very large number. And to help you ground how big that number is, if you look at every single atom, and I mean truly like everyone, you, me, Nick, mountains, ocean, every single atom on Earth, if you were to add all of that up, it is estimated to be just 10 to the 50, as in there are potentially more chemicals out there that are atoms in our Earth. And again, just to give you an upper limit, the entirety of the observable universe is estimated to have 10 to the 80 atoms. So it sits comfortably right there at these cosmological, astronomical numbers in terms of the scale of the challenge that we are talking about. As Nick keep reminding me, you know, the answer to the life, universe, and everything there is is obviously 42. We know that. So let's focus back on cancer. To understand cancer, we obviously do not need the whole 10 to the 60. In fact, it turns out we need a tiny, tiny subset that we have worked with the BigQuery graph team to model. So it turns out we need about just 15,000 chemicals and 20,000 reactions, and we want to perform graph searches on that little graph. It turns out if you look at expanding your search space to a radius of 10 chemical reactions, so starting from chemical A and looking for is it possible to produce chemical B that is truly important for cancer, and looking through a sequence of up to 10 chemical reactions, you can end up with some pretty big numbers. That is 10 to the 31 possible, and I mean biologically plausible, pathways that can produce chemical B from chemical A in just 10 steps. Now obviously life does way more than 10 steps, but this is the scale that we're talking about in here. And so if we can switch to the demo, please, what we would like to show you is an exciting attempt of how to use BigQuery graph and other technologies to try and tackle that problem. Now this is a BigQuery notebook. Just hold on a minute, Mo. We just need to switch to the demo. In the first attempt, we basically use classical approach, row SQL, recursive, loads of optimization. This is a code or basically a query that is written by highly skilled, highly trained software engineers to basically maximize your performance. And if you do that and ask the question about can I produce chemical B from A in four steps or in four consecutive chemical reactions, you get 448 rows in a few seconds. Easy peasy. Lovely. And this is basically the inner working of all the stuff that are happening in the background of how BigQuery is tackling these mergers and joints. quite exciting in terms of where we are now, which is way more exciting, is inter-big query graph. So basically, this, I love this, these five lines of codes are basically the equivalent of that really complex query that we wrote up there. And not only is it better in terms of speed to develop, it is much better from a maintainability, human readability, and understandability. And as you can see, running that same query takes just a few seconds and this is basically the output that we have in here. And just to help orient you into a couple of exciting bits, one of the beauty about the visualization that is built into the big query graph is the ability to visualize the graph that actually provides insights immediately as you see. So imagine if you're a clinician looking into this. What we're saying is that trying to come up with biological plausible ways of going from this chemical into that chemical on the right-hand side, there are, as you can see, numerous ways of doing so. Drugs, and again, I'm generalizing here, one of the ways they operate is they tend to block key pathways. So by blocking this key pathway, you are able to starve cancer of a key ingredient that basically makes cancer, cancer. Now, as we can see in here, there is a clear escape mechanism. Now, having that information at the time you're designing your drug is absolutely crucial for designing the right drugs that will basically benefit the patients or Miss X, as Nick has highlighted earlier. And with that, it's basically the first bit of the demo. It works. And again, the key messages to highlight in here is that, first of all, BigQuery is really cool. I mean, as a technology platform, as an infrastructure, there is so much there that basically allows tech buyers or companies of all sizes and all verticals to do some really cool stuff, including some astronomical things that would have been completely out of, you know, not doable before. Second bit is the, we just need to go back to the slides. Oh, yes, please. And, thank you, Nick. Graphic language, again, with the visualization as we have highlighted earlier, does deliver insights within seconds into things that would give you an information advantage when you are designing your drugs. and with that, I will hand back to Nick. Yeah, so you've seen this gives the scientists out by cortex superpowers. Now, what do I mean by that? It means it allows them to ask questions at a rate that has never been seen before. As in, they can ask and answer questions at a fundamental mechanistic way. We don't use ML, you know, it's a mechanistic sort of knowledge graph. So, it's actually grounded in truth. So, there's no hallucinations and this allows us to be able to sort of partner with large pharma and others to actually provide a completely transparent approach. Now, the future for us is to increase the number of hops, the number of jumps that we can make and to really develop this in silica representation of the tumor and this allows us, thinking about Miss X, you know, I said that she lived in California, but what happens if she lived in China? What happens if she lived in Delhi? You know, those bacteria are going to be different. You know, it isn't, we want to move away from this idea of one drug being used across everywhere and assuming that everybody's actually going to respond to it. Now, of course, the great beauty about the graph query language is if you think about it, you know, this is what, this is at the moment what our scientists are actually sort of using at the moment. But if you think about it, actually, it doesn't have to be written by the scientist. And what we're working on at the moment, we're just going to give a little sneak glimpse of this and we're going to have another demo, which is always a little nerve-wracking after the first one has not worked. So, who else can write that query? And what I'd like to do is introduce the first site of what we call carbon knowledge agents. Now, what this is is an agentic sort of rag built on top of our vast knowledge graph to actually build those queries. Now, for the second time, can we do the demo? Fingers crossed. If we can switch, please, to demo. You can switch to the demo. Excellent. Excellent. So, what this is, this is our vast knowledge graph. We're not going to go into this a huge amount. But what Mo's going to do is actually demonstrate how we can use our carbon knowledge agent to actually traverse the knowledge graph and answer really important questions. So, Mo. Fantastic. No, please. So, imagine you are a scientist and you are curious about, for example, what are the most common bacteria in breast cancer patients in a specific location? So, if all you have to do, and again, this is the schema of our knowledge graph that houses information way beyond chemicals. So, if I was to type the question, so what are the most common bacteria in, for example, breast cancer, here we go, breast cancer patients in California, as an example, what will happen is that that sentence is then broken down into different segments, the first of which highlights at the top there which parts of the graph is needed to answer that question. At the bottom there, it basically highlights all the filters needed to apply to that graph to basically obtain the answer, and by running this query, you actually are given or immediately provided the total number of counts of all the bacteria in all the breast cancer sample patients that are existing within this knowledge graph. And what's amazing is we can then ask the other question about what happens if Miss X was living in China. Yeah, absolutely. So, for example, you could say, how about China? Let's do that. And what it will do, it will automatically figure out what you mean by that, and just simply speaking, it will change the entity country, i.e. the country or the location you want to run this query on from the U.S. to China. And again, by running it, it will basically obtain the results for that nation. Excellent. So you can see there are differences there. Now, again, we're working on this and always happy to chat about this. Can we go back to the slides, please? Possible. Excellent. Okay, so we are an odd company. Yeah, you've probably worked that out by now. We are slightly unusual in the way we do things. We'd like to announce that, you know, it's fantastic that we actually now have Draper Associates on board of one of our sort of VC backers. Tim Draper is a fourth generation VC from sort of Sandy Hill in Silicon Valley and is sort of backing the slightly weird and sort of crazy world that is Biocortex. And sort of thank you. And we'll hand you back to Candice now. Thank you, everybody. Thank you. Thank you so much for the amazing demo, Nick and Mo. Has anyone actually has struggled with explaining to your parents what you do at work, especially in your tech? I'm sure I have. Now I can say I play a tiny little part to help fight cancer. So I'm so much looking forward to continue our partnership together and build this joint vision together going forward. So to recap, you might remember, we talk about three major challenges in adopting graph. data silos and maintenance overhead, performance and scalability bottlenecks, lack of graph expertise. And then with our approach, we believe we can solve these challenges by bringing graphs to your BigQuery data with zero ETL on one single copy of data. Leverage BigQuery large-scale infrastructure to scale your graph to billions of nodes. and the interoperability between query of SQL and graph allow you to continue using your existing SQL skills, lowering the entry bar for majority of users. And it's our vision to have a unified graph solution at Google Cloud where you have Spanner Graph that's optimized for online operational transactional workload and you have BigQuery Graph that's optimized for batch and analytical graph workload. We're so excited to see what kind of smart applications that you want to build with BigQuery Graph for use cases like fraud detection, supply chain management, social network, and anything that you can imagine. This is just the start of our journey and if you're interested to partner with us, feel free to scan the QR code and then we'll reach out to select a partner to continue along this journey together. We also have a demo on Customer 360 product recommendations at the showcase floor at Export, so feel free to check it out. Tomorrow we have another breakout session on Spanner Graph if you want to learn more. Thank you so much for joining today. It's our great pleasure. Thank you so much for joining today. It's our great pleasure. Thank you. Thank you. Thank you. Thank you.