 I'm here to talk about human and non-human identities at Google Cloud. We consider them as the bedrock of all things that you do at Google Cloud. Therefore, it's a very critical responsibility that we believe we have for you. We're going to talk about a number of things, but for this presentation, we have four people, myself, Ravi Shah. I am the group product manager for all things related to identity at Google Cloud. And with me, I have Sean Liu, who is product manager on my team, as well as our friends from Yahoo, Sai, and Henry. So you'll hear from all of us over the course of the next 45 minutes, and we're going to cover through a number of topics, including how we believe that the industry is shifting towards identity-first security. We'll talk about human identities, non-human identities, and then we'll have a quick panel with our friends from Yahoo, and then recap and some next steps for us. All right. So identity-first security. What do we mean by that? We believe that the industry is actually shifting towards this model where identity is really the bedrock of their security. And customers are asking for a number of capabilities kind of corely embedded within the human and non-human identity stacks. So what are those capabilities? If we look at the human identity parts of it, really what we hear from customers and what we believe where the industry is going is comprised of a few things. One is, for humans, customers are asking that MFA needs to be enabled by default. The reason being, it is one of the most critical sort of security features that can reduce the attack surface significantly. We also see a great demand for having a core platform level capability for re-authentication around some of the sensitive actions. We see that customers are asking for strong session management capabilities. Nobody wants long sessions or long-running sessions for human identities, whether those are active sessions or idle sessions. We see a lot of demand for customer-aware access, meaning having some understanding or context-aware access, sorry, having some understanding of the customer's context and using that to really define what the security posture the customer has. And last but not the least, the requirement to support 3PIDPs through federation capabilities. That's on the human identity stack. On the non-human side, we see a shift from token-based identities to cryptographic identities. We see a shift towards not just TLS, but MTLS. We see a demand for short-lived identities that are rotated automatically. We see a shift towards strong attestation, meaning only the machines that can assume a particular identity should be able to assume that. Nobody should be able to impersonate that. And last but not the least, same as human identities, we see a demand for an ability for federation so that customers can connect their workloads from outside of Google cloud to Google cloud. So this is a big shift that is happening in the industry. And with that in mind, we have constructed what we call our identity-first security stack. So what is this identity-first security stack? Let me walk you through some of the key sort of pillars of this stack. So of course, at the bottom, we have human and non-human identities. But on top of it, support for both federated and non-federated authentication. That's kind of one of the most foundational pillars. Moving on, MFA is a key part of the human identity side of things, as well as re-authentication, as I mentioned. And then, on the non-human side, it's IP and network-based restriction, meaning the workload should be able to access the APIs and whatnot based on what IP addresses they're coming from and what network they're coming from. And MTLS, like we talked about, so that both client and server can actually authenticate themselves. The last but not the least, we see a lot of demand for this identity threat detection and response, meaning in line, in real time, customers are asking, how can we detect anomalous patterns and help you respond to these anomalous patterns in real time so that the attack can be contained if there were to happen one for your environment? So this is what we believe is the identity for a stack. There are a lot of elements of it, and we'll go through each of these pieces one by one. So let me jump into sort of the next piece here, which is on the human identity side. So let's talk about what do we believe, what do we think we need to build here. But before I go, I want to ask a simple question for all of you. What do you think is the most common password in this country? Password 123, wrong. Wrong. Four fish, no. No. Actually, you're very close. So the most common password in the country is 123456. That is just unbelievable, right, how simple it is. And now if that is the case, what does it really mean? It means that it is very, very easy for an attacker to actually get access to your environment. And if that is the case, we got to have additional layers of security. And that is why in November of last year, we announced our intention to enforce MFA for all high-privileged users. That is the intention that we announced. And we have been on this journey to actually slowly and steadily enforce it across Google Cloud. So for resellers who actually have access to a lot of other customer accounts, we are going first. And on April 21st this year, which is in the next few days, enforcement of MFA will begin. For the next set of individual developers, May 13th is when MFA will start getting enforced. And then enterprises, where I would assume most of you belong, in Q4, enforcement will begin. You must have seen sort of MSAs go out for this. And we realize that your environments are quite complex. You may be using third-party IDP. You may have an MFA enforced through your IDP. You want to make sure that nothing breaks. So we want to make sure we take care of all your use cases and give you sort of enough time to actually respond to it. So that's our timeline. We're moving in this direction very, very fast. But once again, I want to emphasize why this is important. If you use MFA, SISA believes that you are going to be 99% less likely to be hacked. So there is absolutely no reason for you to not adopt MFA. So if you have not thought about it or have started thinking about it, please do. Enforcement is coming. And we want to make sure all of your accounts are protected. Next, let's talk about re-authentication. So what do we mean by re-authentication? It basically means that every user must validate their identity beyond initial login. Now we realize that if we enforce it for every action that's being taken, it would be very, very painful and full of friction. Therefore, what we have done is we have identified a set of sensitive actions like setting policies, setting IAM policies, billing and tag modification actions. Some highly sensitive actions that we believe need to be protected with re-authentication. But once again, to make sure that it is not a highly frictionful experience for you, we have made sure that for any time you re-authenticate, that thing is valid for next 15 minutes. So we have a certain amount of grace period that we have built in. And at the same time, we'll give you the ability to opt out at desired resource hierarchy level. So you can say, at this project level, I don't want to have re-authentication, and that will be available to you as well. So here's a quick demo of how it's going to work, right? In this case, I'm trying to give basically a user permission or change the permission on this for this user. So this is the user name. I'm going to try and assign a role related to billing, right? So this is a sensitive action. If somebody changes my billing profile, that's not a good thing. Therefore, when I try to save it, I'm going to be asked to re-authenticate. And that's, again, a very simple experience. Once you do it, you'll be able to move ahead, and that's it. So I'm sure you all have seen re-authentication in different flavors, in different sort of realms of your life, whether it be on your phone or some other websites. But this is what will come on Google Cloud as well. Now, on top of that, we don't want to stop sort of at re-authentication. We don't want to stop at MFA. We don't want to stop at re-authentication. We want to go give you even more controls. So this is where our session management capabilities come in. We realize that customers don't want a long-running session or a session that runs for days and days and weeks and weeks, right? We want to give them some control. So we have built this session management capability where your active session length is going to be, by default, limited to 16 hours, which means after that point, you have to re-authenticate, which is a good thing, right? You don't want your session to be hijacked and being used to exploit and get access to your resources. So on the right, you see a quick screenshot of how that would look like. Right now, we have active session length management capabilities. Very soon, we would be releasing something related to idle session length as well. But that's something a little bit further out. So we'll talk about it more as it gets closer. Last piece. We don't want to stop again at session length management. We want to make sure that your assets are protected whenever a potential attacker is trying to access it. And therefore, we are working very heavily on this identity threat detection and response capability, where what we are going to do is identify if there are certain anomalous behaviors from a particular identity. For example, if a user who generally logs in from, let's say, United States, all of a sudden, they log in from Russia or some other country where they don't log in from. That's a typical location for them. We want to make sure that that pattern is kind of recognized. And in response to it, we're going to just ask that user to re-authenticate, for example. And once again, if they do that, they're all good. They can move ahead. But the point is, in real time, we will detect this anomalous behavior. And we will help you respond to it, validate that the user is the right user, and essentially give them access. So these are five different types of actions, like suspicious actions or identity, reputation, and things like that, that will be built in to our identity threat detection and response capability that we will be soon releasing in preview. So if you want to sign up for it, please let us know. And we would love to have you on this program. Now, last piece. We've talked about various controls that we have built. But if we look at our human identity stack, we really have sort of a very broad spectrum of capabilities that's available. On the one hand, we support sort of full Google Cloud as the IDP kind of pattern where cloud identity can be used, and you can use cloud identity as your IDP. On the other side, you can have completely syncless federation through what we also call BYOID, where you're using your third-party IDP, and those identities are used to essentially log into Google Cloud. And we also see a lot of cases where customers want to have cloud identity for their majority of use cases, but in certain use cases, they want to use federation. So we support this mixed model as well. And so all of this is very, very much supported, and we see customers, a lot of customers, actually falling into this mixed mode. Now, the question would be, okay, which services support BYOID or federation? 95% of our services and products today support identity federation. We released a bunch of capabilities last year. We are releasing many more, including one of them, which is scalable groups. And then many new capabilities, like all these controls that we talked about, the RE-Auth, MFA, they will be coming to Workforce Identity Federation as well. So this platform is going to continue to evolve for cloud identity as well as identity federation across all these controls that we have talked about. And last but not the least, this identity federation capability really enables a number of syncless SSO capabilities. I could go on and on about it, but since we're short on time, I would say GKE, BigQuery, both of these benefit tremendously from single sign-on capabilities that we enable, as well as Google's own SaaS apps like SecOps or third-party SaaS apps that use IAP will be able to use BYOID for authentication. So now I covered a lot of ground on human identities. For the next part on non-human identities, I would like to invite Sean on stage. All right. Thank you, Ravi. So let's talk non-human identity. With the rise of microservices and the explosion of these multi-cloud deployments, we're seeing significant amounts of non-human identities all across the board. If we look within our data, large enterprises, some of them have 20 or even up to 50x number of non-human identities versus every one of their human identity, a lot of them having a lot more permissions and privileges than those human counterparts. That is why it's super important for us to look at the security of these non-human identities. At Google Cloud, we think about non-human identities in terms of two main scenarios. The first scenario that we focus a lot about is workload to GCP API access. If you have workloads hosted on Google Cloud or off of Google Cloud, we want to make sure Google Cloud is the most secure platform for you to integrate in and call out APIs. On the other hand, we also care a lot about workload-to-workload authentication, and this is a more recent effort. With all of these microservices now on Google Cloud, workloads need to be able to communicate with each other in safe and secure ways, and this has to be standard-based, works across multi-cloud, so that these workloads can work together. Let's talk about the first one, which is workload-to-GCP authentication. If you have a workload that's hosted off of Google Cloud and you are authenticating into Google Cloud, some of you might be using a service account key, and this is a big anti-pattern that we have been telling customers over the last couple of years. Service account key is a big problem. We see tens of thousands of leaks every single month. We see hundreds of compromises that gets reported to our CISO office every year. This is one of the biggest attack vectors at the moment for non-human identity, and we want to make sure that most customers should not be using this. And you can imagine that the big problem with service account key is that if you have this in your system, there's no owner to a service account key. It's not auditable, so it's really difficult for you to kind of manage. With workload identity federation, you can get keyless access to GCP, and just by using, if your workload is hosted on AWS, Azure, GitHub, GitLab, you can use the native credentials of those platforms to authenticate into Google Cloud. You can map the identities that are in those platforms into Google Cloud for IAM policy assignments. Now, this is great because not only is it auditable, it's short-lived, but it's also based on standards like OIDC and SAML. Today, we're making workload identity federation even better. We're expanding the support from not just OIDC and SAML to also X509 certificate. What does this mean? If you have a certificate authority today and you're issuing certificates, you can set up integration between your certificate authority and Google Cloud. Once that trust is established, any certificates that you deploy onto your workload and the subject names can then be put on IAM policy to grant access to Google Cloud resources. This is great if you have multi-cloud deployments and you don't want to set up a whole bunch of different federation policies. It is also great if you already have X509 credentials within your system already. And finally, this is actually going to bring a whole new level of security. When you use workload identity federation with OIDC and SAML, or even with service account, the tokens are kind of still stealable, even though they're one hour long. With X509 federation, the tokens are actually going to be bound to the certificate that's on your workload. And we have, in private preview, an enforcement to enforce mutual TLS-based authentication between your workload and Google Cloud API, making this actually the most secure authentication method that is available today. Let's see this in action. So, the first thing we're going to do is we have a script here. And the script is just trying to access a GCS bucket. If it succeeds, it's going to print out the content of the GCS bucket. If it fails, it's going to print out access denied. And we're just going to first try to run the script. And as you expect, there's no federation set up, so access is denied. Now, let's flip over to the administrator view. Then administrator would come in and set up a workload identity pool with an X509 provider. And if you look at it, it's fairly simple. You just need to set up an identity mapping, which is how will the identities in the certificate map into Google. You also need a certificate from your CA that will set up the trust relationship. Once this is set up, the federation is complete. Now, we're going to go ahead and create an IAM policy. We're going to create an IAM policy for GCS bucket, giving it the object viewer role. And we're going to grant it. The principle we're going to grant is actually a specific certificate's name. And here it's like spiffy trust domain path one, path two. That's actually the subject name of a certificate. Now, let's flip back to the workload. If you look on the workload, there's already a certificate and a private key that's on the workload. We're going to actually now use the client library to make this entire process simplified. We're going to go ahead and generate a credential configuration file inside Google Cloud. As you know, like, if you're using the client library, you don't want to change your code or anything. So all you need to do is generate this file. It's not a private or public key. It's just a configuration file pointing to where the certificates are. And from then on, the client libraries know where it is. And all you have to do is run the exact same script. You don't need to make any code changes. And you can see that the access would be successful. Okay. So that's workload to GCP API access. Let's talk workload to workload authentication. So if you have microservices and a lot of these workloads across your environment, you might have thought about setting up identity for zero-trust workload-to-workload authentication. And this is typically extremely difficult. And Yahoo has done it. They'll talk a little bit about it. But it takes multiple years of investment to set up things like identity directory, set up your PKI, set up attestation, set up an agent on workload so that these credentials are automatically managed and rotated. Now, today, we're going to make this really easy with just a few Google Cloud, GCloud commands. In public preview, we're going to allow GKE workloads and in private preview, GCE and Cloud Run workloads to automatically get these SPIFI-based identities that can be used for workload-to-workload authentication. The administrators just come in, set up trust domain identity, and developers can then spin up workloads as usual. And when they spin it up, workloads will get attested to attestation policies that's defined by the administrator, and they'll get back credentials that can then be used for workload-to-workload authentication and authorization. Let's see how this works in practice. So the first thing the administrator needs to do is attach a certificate issuance config pointing to your certificate authority to a workload identity pool. In the GKE case, you can use the default workload identity pool that Google is already managing for you at the project level, or you can define your own workload identity pool. The workload identity pool acts as a custom trust domain that you can use in your nomenclature for SPIFI. The next step is you'll deploy... You'll create a pod spec, and this is just a back-end inventory service we're going to create. And once you deploy, you can see that now there's a couple of files that Google is automatically managing on behalf of you on this pod. There's a certificate, which will include the full SPIFI ID, including the trust domain, the Kubernetes namespace, and Kubernetes service account. It will also include a private key and a trust bundle, which will authenticate things, requests that are coming in. We'll see that in action soon. Next, we're going to spin up a Cloud Run instance. And this time, the Cloud Run instance is a front-end payment service that we're going to spin up. For Cloud Run, administrator is defining a custom SPIFI ID that they're associating with Cloud Run. Attestation happens, and when it's successful, Cloud Run also gets the same sets of certificates, trust configs, et cetera, on file. Once it's set up, we can try and make a request from this front-end payment service to the back-end inventory service. And you're going to see that, actually, the access was denied. The reason for this is because today, we're actually using this service in conjunction with Google's Cloud Service Mesh. And there's an authorization policy, which is saying only the front-end inventory service can access the back-end inventory service. And this payment inventory service identity should be rejected. And given that, we're going to now spin up a second Cloud Run instance, this time with the right identity, the front-end inventory identity. And the attestation is going to happen. We're going to check against which Cloud Run instance is being spin up based on the administrator's configuration. The same configuration files are going to be passed. You can make a request from the front-end to the back-end. You can see there's an MTLS handshake that occurs, both client and server authentication, and also the access was successful. Let's recap this a little bit on the slide. So essentially, with managed workload identity, we're enabling defense in depth. There's actually three layers of control that we're providing customers today. The first layer that we have is PKI-based authentication. So if you remember, at the beginning, you're configuring a certificate authority that's deploying certificates. You can have one or multiple PKIs to define this interaction. And when the authentication happens, there's both client and server-side handshake. The second part is trust domain-based validation. So customers can define one trust domain for all of their identity, or in more complex scenarios, they can create multiple trust domains and set up federation between specific trust domains. This is great for complex organizations or if you have merger and acquisition scenarios. Finally, with the authorization policy I showed you, these SPFY IDs can be used within Google Service Mesh. It could be used within your own service mesh. It could be used in your custom solution. It doesn't matter. But the SPFY ID that's defined by the administrator and governed by the administrator is ultimately used to make access decisions. And with that, that is the complete story that we have at the moment for workload-to-workload communication. Now I'm going to pass it over back to Ravi, and he's going to do a panel with Sai and Henry on how Yahoo is doing this within the organization. Thank you so much, Sean. I think there's a lot of interesting stuff that we're doing across human and non-human identities, as you saw. And, well, it's not worth it if customers are not using it, right? That's why we invited our friends from Yahoo to really talk to us about that and share some of their experiences. So we have with us Sai and Henry. If you may please introduce yourself. Hello, I'm Sai. I'm a security engineer at Yahoo Paranoids. Paranoids are the information security organization at Yahoo. In line with Yahoo's mission to be a trusted guide in digital wilderness, Paranoids' mission is to enable business by defending against dedicated adversaries, protecting Yahoo systems, and securing our user data. Thank you, Sai. My name is Henry. I'm part of the security platforms team, and our team is responsible for implementing and deploying solutions to address our properties, service authentication, and authorization use cases that satisfy the requirements that are set forth by the Paranoids organization. Fantastic. Thank you, Sai and Henry, for joining us today. Before we get started and getting into the deeps of, like, how you've implemented it, we'd love to hear what were your top priorities as you were designing your systems around your principles? Absolutely. Security is paramount at Yahoo. As Yahoo Mail is a flagship product at Yahoo, as they migrate to Google Cloud, security is always our top priority or day-one priority. So as every organization has some security goals, ours are rooted into our security principles, and those look like this. Centralized identity management, authentication, and authorization decisions to be time-limited, and always requiring periodic renewal. Auditability. Obviously, everyone agrees about that. And the least privilege. We also agree about principle of least privilege and separation of duties. Remote access, especially for human remote access here, we're talking about, like, backing that up with mandatory MFA using hardware tokens. Fantastic. So, yeah, those are great principles. If you could tell us more about, like, how did it come to life for your human identity sort of setup at Yahoo? Sure. Those security principles serve as our guardrails and help us drive and navigate, like, navigate through those complex decisions, and now those turn into security requirements. For human, it looks like this. As we see for Google Cloud as we evaluated, these were our security requirements, like the Google session isolation with the rest of workspace applications here, and rule-based configurable session lengths. So, ability to, like, always re-auth when you're trying to switch across admin and non-admin sessions, where I say, and then requiring to re-authentication to switch the project scopes, as the scopes might always be different across the use cases, mandating MFA, auditability of all the cloud activity back to principles, automated onboarding, offloading, and so on. And then, to bring this to life, I'll pass it back to Henry, who's our platforms engineer. Sure. Thank you, Sai. So, as Sai mentioned, our decision was to use Workload Identity Federation and Workforce Identity Federation, sorry. So, I want to start by introducing Athens, which is a product that, it's a service that we have developed at Yahoo and contributed to CNCF. It's a CNCF sandbox project. It actually provides two major features that we utilize heavily at Yahoo. The first one is it actually provides an identity to all of our workloads, regardless of where they're running, on-prem, data centers, or in any of our public cloud environments. And it provides a SPFI identity in a form of next finance certificate. This is what Sean was talking about a little bit earlier, and we're quite happy to hear that Google is actually adding native support for this capability within GCP. The second one, it's actually, it's a role-based authorization system. So, it actually, based on industry standards, access tokens, ID tokens, and that's what we're utilizing to actually implement and take advantage of workforce identity federation within GCP. So, what are we doing? So, when we're provisioning a specific project, what we automatically generate is specific set of rules. So, what we do is, like, you know, we separate, we generate a, we create a project, we associate with a concept of a domain within Athens, think of it as a namespace, and once we set up the association, we automatically, as part of the provisioning process, we generate roles that are associated within, between Athens and to GCP. So, this allows us to have a specific set of access points into GCP console, so you don't log in as the same user all the time, but you can say, for example, an admin user or a power user or a read-only user, and this allows us to say, depending on which role you're logging into the console, you can have a different session timeout. For admin roles, that could be 30 minutes, for power user roles, it could be a little bit longer. So, if we go through the flow diagram here, the user logs into Athens. As I mentioned, Athens is an authorization system, not an authentication system. So, what happens here is the user will be redirected to your identity provider, whether that's Okta or whether that's an LW directory server, you will authenticate, and you're back into Athens again once you're authenticated. What Athens is going to do is going to look up its own authorization system to see which projects do you have access to and what type of access you have. It's going to present you with a choice of options. You choose one, and then once you make the connection, at that time, we are utilizing workforce identity pool SAML integration here. We generate a signed SAML document, and then we publish and pass it on to GCP console. Now you're logged in into GCP console. The second use case that's a common use case that we want to talk about is SSH access. In this case, there is no console access, and here we want to utilize GCP IAP to create a tunnel through IAP to log into our instance. As you can see on the right-hand side and my right-hand side, when we launch an instance, there are a couple of agents that are running on our foundation images. One is the SPFY agent, which I already mentioned. It gives an identity in the form of next finance certificate, and the next one is our Calypso agent. Calypso is our user access management system, which is also a solution-based, a solution that's built on top of Athens. So what does that, what the Calypso does, it actually generates a profile that says which users should have SSH access to the specific instance with restricted set commands, like, you know, some of them can only have pseudo access, some of them only read-only access. So as part of the, when we launch the instance, these agents automatically go and provision the system ready for the user to log in. So in this case, user has, gets an SSH CA credentials, talks to Athens again, just says, hey, I'm trying to access this specific instance, so I need some GCP credentials. Athens verifies access, gives you an ID token, and then you use that ID token to generate a tunnel through GCP IAP. So in this model, instead of using SAML, we're using the OIDC provider for the Workforce RID Federation. And once you set up a tunnel, you actually are able to SSH to your instance directly. Fantastic. Yeah, that's a pretty comprehensive framework that you guys have built, so thank you for walking us through it. Let's talk a little bit about your non-human identity setup, and how does that work? Certainly. So for service identities or non-human identities, in this case, the requirements map look like this, like minimizing human interactions in production deployments. Obviously, we don't want humans to be actively interacting in the production deployments. It should be your, like, continuous deployment tools deploying stuff into the production environment. Eliminating user service account keys. As Sean alluded earlier, we all agree about eliminating the user service account keys and relying on service identities, and, like, in this case, the federated identity. Dedicated workload identities for use case. We all, like, should pivot into defining a use case for identities that we are creating, ensuring that those identities serve a specific purpose at any given time, and then also manage the lifecycle of those identities. And X, Y, on insert base service authentication for cross-code access. This is specifically for all of us who are in this hybrid environment where we have that cross-code access needs. This is, like, a mandatory need for us at the moment. And the decision, again, is to use, like, identity federation solutions. In this case, it's going to be the workload identity federation. And to bring this to life, again, I'll pass it down to Henry. Thank you, Sai. So, yeah, so in this case, we're using workload identity federation, and very similar to our workforce identity federation setup, when we create the project, we also automatically provision the workload identity pool in your project. So from our user's perspective, they don't have to do any extra steps of configuring access to their projects. So we set up the workload identity pool, we set up the proper attribute mappings. Subject is your principal's email address. Because we're accessing our GCP services using service account, we want to be able to go back and see exactly what user was who actually requested this access through this service account, right? So that actually, GCP gives us correct capability by providing the mapping between the subject and the principal's email. So if you look at the audit log, you know exactly which user it was who obtained the service account to access the service account, to access GCP services. So very similar, a common use case that we do here is our screwdriver, which is our CICD pipeline. So CICD pipeline, very straightforward, we obtain service credentials, and once we have the service credentials, now we can actually deploy our instances or manage our GCP services without having any type of static credentials. So if I would go to a very specific use case, in this case, we're looking at CICD workflow pipeline. Our projects, again, very similar to when we launch our instances where they have the agents running, every single CICD project that we deploy, it actually has the agents. One is the SPIFI agent. So SPIFI agent gets the identity first, and then we use that identity to obtain the ID token from Athens. And then once we have the ID token from Athens, then we do our dance with GCP services, STS and IAM. In this case, we're utilizing workload identity pool. And the end result is we have an access token back to our screwdriver project, and then the screwdriver project, in this case, it could be Terraform running within your project, we'll be able to use that access token to access GCP services and manage your infrastructure. Fantastic. So you gave us a lot of details. I would love to see a demo from you. Absolutely. So obviously here we talked about logging into the instance. So here we're logging into our identity provider, MFA. We require full of our accounts. This is the first page that you see from Athens, right? So I was talking like, you know, when you see a prompt that says which project you have access to, which role you have access to, this is the page that our users see, two projects, one for demo 2024, one for 2025. So I want to log into the second project using power user access role. So now I'm logged into my GCP console, and let's assume right now, like, hey, we're going to launch a new VM instance. So in this scenario for this demo, we're going to use our CI-CD platform, and we're going to use Terraform to launch a new VM instance, and then eventually we'll try to SSH into this instance. So let's switch to our Git reboot to see what we're doing. So there's the main.tf, that's your Terraform file, which is pretty straightforward, just launch a VM2 instance. I want to focus on our screwdriver file. As you can see at the bottom, it has three major steps. One is we're going to install Terraform, very straightforward. The second one is that's where we get our GCP credentials. The focus here is we want to see how easy we want to make this to our end users. We want to make it pretty straightforward. We want to make sure developer productivity is a big concern for us. So all you have to do as a user, you have to provide three fields here. Athens domain name, what is the role name, and what is the service account you're trying to obtain. Based on those three details, the step, the screwdriver step, our CI-CD platform, automatically fetches the credentials. And this is the Athens UI. So now when we talked about the Athens roles, now you have all the roles. In this case, we're doing a CI-CD deployment, so I don't want to use one of those admin roles. So I have a least privileged access, so I have a separate role. One thing you can see here, I have my project here that's authorized within the role. It also has an expiry date. So I don't want this project to have unlimited access. Maybe our governance requirement is to review the membership every 90 days or every 60 days. Our Athens authorization system provides much more capabilities, more settings that you can configure to get notifications, how long your tokens are valid for. So we take advantage of all these options to satisfy our requirements. So once we have all these settings set up, let's switch to our CI-CD platform, click on start. It takes about two to three minutes, so we're going to basically fast forward this part. and at the end of it, once our pipeline is complete, if you look at it, now we have a VM instance running in our project. So the second part of this thing is like, well, the VM is now running. Let's SSH into this. Let's see how straightforward that is for us. So let's switch to command line option. First, we're going to run gcloud just to make sure, hey, can we set up a tunnel? Let's assume, hey, what are the instances in my project? First thing, it says, hey, I'm not authorized. Great. Let's run our gcp-fed command. As you can see, I just prompted for MFA authentication again. And very similar to our user console we saw in the console, I'm prompted for my project. Which project do I want credentials for? Again, I'm going to pick option one, which is a 2025 project. And this automatically goes behind the scenes and gives me credentials. So if I go back and run my gcloud command, now gcp says, yep, here's your VM instances running in this account. I want to SSH to the second instance. We provide our users with a simple wrapper script called gssh. I'm going to run with the dash v option so we can see what's happening behind the scenes. It's a straight SSH command and it also has the proxy command option specified. It's a gcloud created IAP tunnel. And then once that happens, as you can see, I'm going to be prompted again for my YubiKey to touch. Again, MFA before I can SSH. Once I touch in, I'm now actually logged into my instance. That's how we have full SSH access to our instances running within GCP. That is fantastic. Thank you so much for comprehensively walking us through your demos. It was really nice to see sort of all the capabilities that we talked about in our identity first security stack come to life. You guys are definitely a power users. Big round of applause for our friends from Yahoo. Now, just before we go, I know five more minutes remaining. Just want to quickly recap things that we showed to you today. We showed a bunch of things that are new that are coming up at Google Cloud. The identity federation features, re-authentication for all sensitive actions, session management capabilities, ITDR, identity threat detection with context-aware access, X509 certificate, certificate-based workload federation, as well as sort of managed workload identities. Amazing amount of capabilities, but we're not going to stop here. We have a few other capabilities that we did not get time to touch on, like support of context-aware access for service accounts. Many of you may be using our customer identity platform. It has now passkey support. And last but not the least, we have a very robust certificate authority service that now supports external key management. So with that, I want to bring it sort of full circle. We started off with this industry moving towards an identical security model. And as you see, as we went through our entire stack, we have basically checkmarked all the areas and we continue to invest very heavily across these areas and make sure that our platform is the leading platform in providing you identity-first security. So thank you so much, all of you, for coming in and for listening in. We're happy to take any of your questions as well as we want to point you out to some of these other sessions which may have happened and now have recording or recap or our booth which is in the showcase area down below. Please visit us there and we would love to have you there, answer your questions, and we can stay here for a couple more minutes and answer any questions that you might have. Get out of here and do it. Get out of here and diceEhf!